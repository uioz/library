# 标题 索引入门

几乎所有的数据库都有索引这个功能.而索引本身也是提升查询效率的最直接的手段.

所以如何利用好索引是非常重要的知识点.

运行如下命令来插入大量的数据:

```javascript
(function() {
	
	db.tester.drop();

	let 
		len = 1000000,
		chunk = [];

	while(len--){

		if(len%10 === 0){
			db.tester.insert(chunk);
			chunk = [];
		}

		chunk.push({
			index:len,
			username:'user'+len,
			age:Math.floor(Math.random()*128)
		});
		
	}
		
})();
```

## explain命令简单使用

利用explain命令我们可以获取命令执行时候的额外信息.

该命令可以在跟随在查询命令后执行也可以在runCommand中执行.

例子:

```javascript
db.tester.find({index:12345}).explain();
db.tester.find({index:12345}).explain('executionStats');
```

explain有多种执行模式我们先来看第一种无参数传入的情况的返回值:

```json
"queryPlanner" : {
                "plannerVersion" : 1,
                "namespace" : "demo.tester",
                "indexFilterSet" : false,
                "parsedQuery" : {
                        "index" : {
                                "$eq" : 12345
                        }
                },
                "winningPlan" : {
                        "stage" : "COLLSCAN",
                        "filter" : {
                                "index" : {
                                        "$eq" : 12345
                                }
                        },
                        "direction" : "forward"
                },
                "rejectedPlans" : [ ]
        },
        "serverInfo" : {
                "host" : "DESKTOP-KJDKMRJ",
                "port" : 27017,
                "version" : "4.0.3",
                "gitVersion" : "7ea530946fa7880364d88c8d8b6026bbc9ffa48c"
        },
        "ok" : 1
}
```

数据引用自:

> https://blog.csdn.net/u012702547/article/details/80606614

| 参数           | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| plannerVersion | 查询计划版本                                                 |
| namespace      | 要查询的集合                                                 |
| indexFilterSet | 是否使用索引                                                 |
| parsedQuery    | 查询条件                                                     |
| winningPlan    | 最佳执行计划                                                 |
| stage          | 查询方式，常见的有COLLSCAN/全表扫描、IXSCAN/索引扫描、FETCH/根据索引去检索文档、SHARD_MERGE/合并分片结果、IDHACK/针对_id进行查询 |
| filter         | 过滤条件                                                     |
| direction      | 搜索方向                                                     |
| rejectedPlans  | 拒绝的执行计划                                               |

__添加不同参数__

explain()也接收不同的参数，通过设置不同参数我们可以查看更详细的查询计划。

__queryPlanner__

queryPlanner是默认参数，添加queryPlanner参数的查询结果就是我们上文看到的查询结果，so，这里不再赘述。

__executionStats__

executionStats会返回最佳执行计划的一些统计信息，如下：  

```json
        "queryPlanner" : {
        },
        "executionStats" : {
                "executionSuccess" : true,
                "nReturned" : 1,
                "executionTimeMillis" : 439,
                "totalKeysExamined" : 0,
                "totalDocsExamined" : 999999,
                "executionStages" : {
                        "stage" : "COLLSCAN",
                        "filter" : {
                                "index" : {
                                        "$eq" : 12345
                                }
                        },
                        "nReturned" : 1,
                        "executionTimeMillisEstimate" : 372,
                        "works" : 1000001,
                        "advanced" : 1,
                        "needTime" : 999999,
                        "needYield" : 0,
                        "saveState" : 7827,
                        "restoreState" : 7827,
                        "isEOF" : 1,
                        "invalidates" : 0,
                        "direction" : "forward",
                        "docsExamined" : 999999
                }
        },
        "serverInfo" : {
        },
        "ok" : 1
}
```

**注意**:输出内容有删减.

| 参数                        | 含义                                     |
| --------------------------- | ---------------------------------------- |
| executionSuccess            | 是否执行成功                             |
| nReturned                   | 返回的结果数                             |
| executionTimeMillis         | 执行耗时                                 |
| totalKeysExamined           | 索引扫描次数                             |
| totalDocsExamined           | 文档扫描次数                             |
| executionStages             | 这个分类下描述执行的状态                 |
| stage                       | 扫描方式，具体可选值与上文的相同         |
| nReturned                   | 查询结果数量                             |
| executionTimeMillisEstimate | 预估耗时                                 |
| works                       | 工作单元数，一个查询会分解成小的工作单元 |
| advanced                    | 优先返回的结果数                         |

#　创建索引

我们的username字段是唯一的,但是MongoDB不知道所以它使用最笨的办法将所有的内容都给扫描了一遍.

使用如下命令来进行创建索引:

```javascript
db.tester.createIndex({"username":1})
```

然后利用username键进行查询:

```javascript
db.tester.find({username:'user123'})
```

查看详细信息:

```javascript
db.tester.find({username:'user123'}).explain('executionStats')
```

输出:

```json
        "queryPlanner" : {
        },
        "executionStats" : {
                "executionSuccess" : true,
                "nReturned" : 1,
                "executionTimeMillis" : 0,
                "totalKeysExamined" : 1,
                "totalDocsExamined" : 1,
                "executionStages" : {
                        "stage" : "FETCH",
                        "nReturned" : 1,
                        "executionTimeMillisEstimate" : 0,
                        "works" : 2,
                        "advanced" : 1,
                        "needTime" : 0,
                        "needYield" : 0,
                        "saveState" : 0,
                        "restoreState" : 0,
                        "isEOF" : 1,
                        "invalidates" : 0,
                        "docsExamined" : 1,
                        "alreadyHasObj" : 0,
                        "inputStage" : {
                                "stage" : "IXSCAN",
                                "nReturned" : 1,
                                "executionTimeMillisEstimate" : 0,
                                "works" : 2,
                                "advanced" : 1,
                                "needTime" : 0,
                                "needYield" : 0,
                                "saveState" : 0,
                                "restoreState" : 0,
                                "isEOF" : 1,
                                "invalidates" : 0,
                                "keyPattern" : {
                                        "username" : 1
                                },
                                "indexName" : "username_1",
                                "isMultiKey" : false,
                                "multiKeyPaths" : {
                                        "username" : [ ]
                                },
                                "isUnique" : false,
                                "isSparse" : false,
                                "isPartial" : false,
                                "indexVersion" : 2,
                                "direction" : "forward",
                                "indexBounds" : {
                                        "username" : [
                                                "[\"user123\", \"user123\"]"
                                        ]
                                },
                                "keysExamined" : 1,
                                "seeks" : 1,
                                "dupsTested" : 0,
                                "dupsDropped" : 0,
                                "seenInvalidated" : 0
                        }
                }
        },
        "serverInfo" : {
        },
        "ok" : 1
}
```

可以看到性能有了极高的提升因为只使用了0毫秒.

建议:

1. 找出最常用的键为其添加索引
2. 文档的索引设计不应该多于两个
3. 不要给查询次数少的操作使用索引

副作用:

1. 一个文档中最多建立64个索引
2. 会增加删除和添加操作的时间

# 复合索引

## 简介

当查询操作中有多个键值的时该索引(查询)操作就被称之为复合索引操作.

索引的值是按一定的顺序排列的,所以使用索引键对文档进行排序非常快.

注意:

- 查询的时候需要将索引键做为首先查询的键索引才有用.

反例:

- `db.tester.find().sort({age:1,username:1})`(我们在username键上做了索引)

为了优化这个排序,我们可以利用这两个键进行排序,这就是复合索引的基本使用方式.

```javascript
db.tester.createIndex({age:1,username:1})
```

这里的Age字段是严格升序排列的,age相同的条目按照username升序排列.

执行如下命令:

```javascript
db.tester.find({age:21}).sort({username:-1})
```

由于username已经按照降序进行排列了,此处执行的sort在执行过程中MongoDB会进行反向迭代,然后依次获取对应的age查看是否等于21,所以该操作非常高效,不需要进行针对进行实际的排序.

执行如下命令:

```javascript
db.tester.find({age:{$gte:21,$lte:30}})
```

在这个例子中MongoDB会按照之前给定的Age索引后进行查询和过滤所以效率非常高效,通常来说如果MongoDB按照索引进行查询,那么查询结果文档通常是按照索引顺序排序的.

执行如下命令:

```javascript
db.tester.find({age:{$gte:21,$lte:30}}).sort({username:1})
```

这个例子中MongoDB首先会按照Age索引进行查找,但是得到的结果集合的username字段不是有序的,所以再执行sort命令的效率不会比第一个例子中的效率高.

- 注意当结果集的内容大于32MB后MongoDB将不会对过大的结果集合进行排序,并且会抛出一个错误

针对最后一个例子我们可以创建一个新的复合索引`db.tester.createIndex({username:1,age:1})`.

这样做非常好因为不需要在内存中对于大量数据进行排序.但是MongoDB不得不扫描整个索引以便找到所有匹配的文档(Age字段是乱序的).

如果对于匹配范围有明确的要求,MongoDB在几次匹配之后就可以不再扫描索引这种情况下**将排序键放在第一位是一个非常好的策略**.

所以在日常使用中`{sortKey:1,queryCriteria}`是比较常见的选择,因为大多数查询只要得到所有结果中的前几个结果而不是全部结果.

















