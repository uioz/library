# HTTP 缓存

# 通过 ETag 验证缓存的响应

ETag 的基本想法就是, 存在服务器上的每一个资源文件都有一个对应的唯一指纹, 浏览器在获取一个资源的时候, 如果这个资源在本地存在(也就是说被缓存了),那么在请求这个资源的时候会附带这个资源的指纹(通过 `If-None-Match` 请求头):

- 如果该资源在服务器被更新
  - 响应新的资源
- 如果资源没有发生改变
  - 服务器返回 304 Not Modified

但是这里存在一个问题, 如果一个资源已经被缓存, 那么每次请求的时候都得进行判断这个资源是否在服务端产生了改变, 也就是说每次都得发出一个检查请求.

这显然不是一个典型的 HTTP 缓存的流程, ETag 需要搭配一些其他策略, 实际上 ETag 缓存就是用于填补其他缓存带来的问题的.

# Cache-Control

`Cache-Control` 缓存控制是另外一种控制缓存的手段, 基本的工作方式是当一个服务端资源被客户端 请求后, 服务端会在响应头上告诉客户端这个资源该如何被缓存, 例如: 服务端告诉客户端 1 小时后才可以继续请求, 在接收到资源的 1 小时内使用缓存.

## no-cache

“no-cache”表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。 因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。

## no-store

基本的含义就是不要使用任何缓存, 每次请求都获取新的资源. 规则不仅仅作用于客户端, 数据经过的所有环节都要这么做, 例如代理服务器.

## public

当指定 `public` 后就表示这个资源的:

- 身份验证
- 响应状态码

都是可以被缓存的(默认不可以).

## private

这个属性是告诉网络传输的中间环节的, 例如代理. 告诉代理不要进行缓存, 缓存只适用于客户端.

例如你可能使用了 CDN , 使用 `private` 则 CDN 不会缓存这些资源, 这也就意味着, 每一个用户获取的同一份资源都是 private(私有) 的.

如果你的资源是动态的, 根据用户不同而获取的内容不同, 那么这个选项就很有用.

## max-age

最常用的属性, 属性值是数值. 告诉浏览器在接收到资源的多少时间内(单位: 秒), 都要使用缓存, 而不是发送请求来获取资源.

# 组合使用策略

# 最佳实践

