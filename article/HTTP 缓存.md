# HTTP 缓存

# 通过 ETag 验证缓存的响应

ETag 的基本想法就是, 存在服务器上的每一个资源文件都有一个对应的唯一指纹, 浏览器在获取一个资源的时候, 如果这个资源在本地存在(也就是说被缓存了),那么在请求这个资源的时候会附带这个资源的指纹(通过 `If-None-Match` 请求头):

- 如果该资源在服务器被更新, 在服务端的资源的指纹也就发生了改变两者不相等
  - 响应新的资源
- 如果资源没有发生改变, 即指纹一致
  - 服务器返回 304 Not Modified

但是这里存在一个问题, 如果一个资源已经被缓存, 那么每次请求的时候都得进行判断这个资源是否在服务端产生了改变, 也就是说每次都得发出一个检查请求.

这显然不是一个典型的 HTTP 缓存的流程, ETag 需要搭配一些其他策略, 实际上 ETag 缓存就是用于填补其他缓存带来的问题的.

# Cache-Control

`Cache-Control` 缓存控制是另外一种控制缓存的手段, 基本的工作方式是当一个服务端资源被客户端 请求后, 服务端会在响应头上告诉客户端这个资源该如何被缓存, 例如: 服务端告诉客户端 1 小时后才可以继续请求, 在接收到资源的 1 小时内使用缓存.

## no-cache

“no-cache”表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。 因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，但如果资源未发生变化，则可避免下载。

## no-store

基本的含义就是不要使用任何缓存, 每次请求都获取新的资源. 规则不仅仅作用于客户端, 数据经过的所有环节都要这么做, 例如代理服务器.

## public

当指定 `public` 后就表示这个资源的:

- 身份验证
- 响应状态码

都是可以被缓存的(默认不可以).

## private

这个属性是告诉网络传输的中间环节的, 例如代理. 告诉代理不要进行缓存, 缓存只适用于客户端.

例如你可能使用了 CDN , 使用 `private` 则 CDN 不会缓存这些资源, 这也就意味着, 每一个用户获取的同一份资源都是 private(私有) 的.

如果你的资源是动态的, 根据用户不同而获取的内容不同, 那么这个选项就很有用.

## max-age

最常用的属性, 属性值是数值. 告诉浏览器在接收到资源的多少时间内(单位: 秒), 都要使用缓存, 而不是发送请求来获取资源.

# 组合使用策略

需要将 Etag 和 cache-control 相结合:

1. 响应可以被重复使用
   1. NO -> no-store -> 停止继续判断
   2. YES -> 跳转到 2
2. 每次获取前都要检查资源是否过期
   1. YES -> no-cahce -> 跳转到 3
   2. NO -> 跳转到 3
3. 资源可以被中间环节缓存(例如 CDN)
   1. YES -> private -> 跳转到 4
   2. NO -> public -> 跳转到 4
4. 需要设置资源的最大缓存时间
   1. YES -> `max-age=` -> 跳转到 5
   2. NO -> 跳转到 5
5. 添加 ETag 响应头

| Cache-Control 指令和说明 |                                                              |
| :----------------------- | ------------------------------------------------------------ |
| max-age=86400            | 浏览器以及任何中间缓存均可将响应（如果是“public”响应）缓存长达 1 天（60 秒 x 60 分钟 x 24 小时）。 |
| private, max-age=600     | 客户端的浏览器只能将响应缓存最长 10 分钟（60 秒 x 10 分钟）。 |
| no-store                 | 不允许缓存响应，每次请求都必须完整获取。                     |

# 最佳实践

简单来讲对于入口文件一般是 `index.html` 设置为 `no-cache`. 这样用户每次在请求的时候即使中间经过了代理服务器, 代理服务器在获取资源前会检查 ETag 以确保资源和应用服务器上的资源一致. 如果不经过代理服务器客户端也会检查资源是否和应用服务器上的资源一致.

在 `index.html` 中可以通过 `link` 或者 `script` 来连接静态资源文件, 只要给静态资源文件的名称或者路径上添加版本号, 例如 `jquery.3da37df.js` 当文件发生变化则资源名称改变 `jquery.94ff1a.js`. 为这些静态资源添加:

- `cache-control:max-age=31536000` 这里的含义是添加一个超长的缓存时间.
- ETag

这样在时间到期前客户端都不会去获取这些资源以尽量节省带宽, 当然 `cache-control` 可以自由设置, 这里的例子只是通常的做法, 但是目的是相同的, 尽可能的读取缓存而不是获取响应结果.

最后的结果就是在每次请求 `index.html` 的时候会产生一些网络流量, 但是绝大多数的静态资源都得到了缓存, 而应用一旦更新 `index.html` 中内联的静态资源地址发生了变化也就打破了之前的静态资源缓存, 从而去获取那些新的资源.

# 强缓存与协商缓存

## 强缓存

通过 Expires 和 Cache-Control 来控制的缓存被称为强缓存, 因为这种缓存是服务端强制要求的, 客户端必需遵循.

## 协商缓存

ETag/If-None-Match 和 Last-Modify/If-Modify-Since 被称为协商缓存.

ETag/If-None-Match 前面我们已经提到过了, 这里讨论一下 Last-Modify/If-Modify-Since.

Last-Modify/If-Modify-Since 是一套当没有 ETag 的情况下的备用机制, 如果 HTTP 会话双方支持 ETag 则优先使用 ETag 其次使用 Last-Modify/If-Modify-Since.

简单来讲 Last-Modify 用于服务端响应头中, 对于的值是多种格式的日期值(值是日期), 告诉浏览器这个资源上次被更新的时间.

If-Modify-Since 则是浏览器在访问这个资源的时候被写入请求头值是该资源响应时候写入的 Last-Modify 的值, 它的含义是文件是否从给定的时间后发生了变化(被修改), 此时服务器会通过响应头以及 Last-Modify 来进行响应:

- 状态码 200 也就是说资源被修改了, 同时响应新的资源, 不要忘记了服务器还会响应 Last-Modify 响应头, 来告诉服务器上的文件修改的时间.
- 状态码 304 也就是说资源没有被修改, 不带消息主体, 同样的 Last-Modify 会被携带.

协商的特性就是 HTTP 会话双方都有发言权, 强缓存中客户端是一个单纯接收的角色.

## 简单拓展

浏览器在地址栏回车重复进入同一个地址, 以及刷新页面的时候. 浏览器就会为静态资源做 "新鲜度" 检查, 如果存在 ETag 浏览器优先使用 ETag, 否则就会使用 If-Modify-Since 来进行检查.

这点可以通过开发者工具的 network 面板来进行检查.

但是勾选了开发者工具中的禁用缓存(disable cache)以及通过使用 ctrl+f5 强制刷新则浏览器不会使用任何缓存, 全部重新请求资源.