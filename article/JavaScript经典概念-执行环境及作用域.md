# 前言

"执行环境及作用域" 是 JavaScript 非常经典且古老的概念(一系列), 这个基本的概念用于解释 JavaScript 是如何运行的.

为什么说古老呢? 因为这一系列概念是在 ES3 中就存在了, 在 ES6 后语言规范发生了变化原来存在的一系列概念可能就只有 "执行环境"(Execution Contexts) 这个名词存在了.

不过无论如何, 对于我来说是时候为这些尘封的概念画上句号的时候了, 文本会掺和着一些 ES6 后才存在的概念来简单介绍它们.

# 从代码开始

由于相关概念过于复杂我准备从一段代码开始, 这趟旅程, 所以请先熟悉一下这段代码:

```javascript
    function test() {

      function buildUrl() {

        var qs = "?debug=true";

        with (location) {
          var url = href + qs;
        }

        return url;

      }

      {
        var b = 20;
        let a = 10;
      }

      buildUrl();

    }

    test.call({
      helloworld: 20
    });
```

# 执行环境初探

执行环境还可以被叫做 "执行上下文" 或者 "活动记录"(比较时髦的叫法). 它并没有对应的实体, 它实际上是一个抽象的概念, 是另外一些概念组成的集合.

而其他的概念, 例如 "变量对象" 是组成执行环境的一部分, 接下来开始介绍这些基本概念.

当代码执行到第一行的时候, 此时我们有哪些有趣的说法:

1. 当前的执行环境类型是 "全局"
2. 作用域链中只包含了全局对象
3. 全局对象作为当前的变量对象
4. this 绑定到了全局对象上

好吧一堆概念蹦了出来, 我们来尽可能简单的解释它们:

- 全局对象 - 就是 window 对象, 当然这取决于代理(浏览器是一种代理)的实现.
- 变量对象 - 与当前执行环境相关这个对象上保存了当前环境下定义的所有变量以及函数. 我们的代码访问变量实际上就是从这个对象上来读取的, 但是我们无法直接访问这个对象.
- 全局执行环境 - 就是此时

此时环境中都有哪些变量呢?

- 只有一个即函数声明 "test"

实际上我们可以打开 chrome devtool 来查看, 而且他很好的说明了两个问题:

![1583944831815](./assets\1583944831815.png)

Scope 中的 Global 一行实际上就可以 "变量对象" 本体, 有人说这不就是 window 对象吗? 还记得之前的定义吗, 这里至少说明了两个问题:

1. 全局对象作为当前的变量对象
2. 变量对象 - 与当前执行环境相关**这个对象上保存了当前环境下定义的所有变量以及函数.**

然后你在仔细想想, 我们定义的 test 函数现在不就是 window 对象的一个属性吗, 而且 `window.xxx` 你都可以不加 window 来进行访问, 这再次证明了 **全局对象作为当前的变量对象**.

# 函数环境

接下来调用函数:

```javascript
    test.call({
      helloworld: 20
    });
```

进入到函数体后, 和全局环境有哪些差异呢?

- 当前的这种环境被称为 活动环境(active execution context)
- 这个函数被压入到调用栈中执行
- 当前的环境是 函数, 区别如下:
  - this 关键字可以使用, 此时被绑定到了一个对象上
  - 存在 arguments 变量
  - 变量对象保存了当前函数环境下定义的所有变量以及函数
  - 控制流交由当前函数的情况下变量对象被称为活动对象

这次我们使用 Firefox devtool 因为 chrome 的不显示 arguments 变量:

![1583946493215](./assets\1583946493215.png)

图片顶部的 test 是调用栈的栈顶, 而下方的范围中的 test 则是当前的执行环境, 其中包含了 this 和 arguments 剩余的则是变量对象上的属性.

这说明了几个问题:

1. 只有函数环境有 this
   1. ES6 中的胖箭头函数是没有的
2. 只有函数环境有 arguments
3. this 和 arguments 是运行时才确定的

其实这也不难理解, 因为这是 JavaScript 为数不多不需要定义就可以使用的标识符, 大部分人在使用的时候只不过是没有思考过为什么它们不需要定义就可以使用而已.

// TODO 下一步块级上下文

// TODO 下一步延长作用域链

// TODO 下一步词法作用域



- 所谓的上下文(context)在 JavaScript 中指的就是 this 切记不要和执行上下文搞混.