# 前言

在web技术发展飞速的时代,技术更新日新月异.为了完成任务使用高阶框架和类库的堆砌早已成了家常便饭.  

有趣的是当自己需要完成某些简单的任务而操作DOM的时候,居然发现无从下手.

这次的问题是,如何获取浏览器的视窗大小,和元素的宽高.

这个问题看似简单,实则不然.当然结果是简单的,但是想要搞懂的过程还是较为不易的.

浏览器并没有直接提供一个简单的属性就告诉你浏览器窗口的大小,或者一个元素的宽高.

为什么?

就拿div元素来举例,我们有很多的问题影响到了元素宽高:
- border 是否纳入宽高的计算?
- padding 是否纳入宽高的计算?
- magin 是否纳入宽高的计算?
- box-sizing:border-box; 时候该如何计算?
- 父元素使用了overflow:hidden;把我们的元素裁剪了,这时候的宽高该如何计算?
- 元素使用了overflow出现了滚动条此时该如何计算?

而如果要获取一个浏览器窗口的大小,你还要面对我们到底是要获取哪个大小?
- 屏幕大小?
- 浏览窗口大小?
- 浏览区域大小?
- 是否包含滚动条?
- 页面中的iframe该如何计算?

当然最终你还要面临一个兼容问题,致敬我们敬爱的IE浏览器,不过本文可不探讨浏览器之间的差异.不过本文的涉及到的内容应该在IE9以上都是可以正常使用的.

# 浏览器部分

浏览器的宽高计算主要通过window对象来完成.

这个对象上提供了几个属性:
- window.innerWidth 
- window.innerHeight 
- window.outerWidth 
- window.outerHeight

用人类语言来描述这几个属性就是.

| 属性名称    | 人类解释                                                     |
| ----------- | ------------------------------------------------------------ |
| innerWidth  | 获取页面可视区域的宽度包括右侧的滚动条(如果有的话).<br />所谓的可视区域就是HTML页面的内容区域不包括浏览器自身的ui所占用的空间(地址栏和菜单栏等). |
| innerHeight | 获取页面可视区域的高度包括底部的滚动条(如果有的话).<br />解释同上. |
| outerWidth  | 获取浏览器宽度.<br />这个十分好理解就是浏览器的宽度,这个宽度中包含了浏览器窗口所占的宽度. |
| outerHeight | 获取浏览器高度.<br />解释同上.                               |
| pageXoffset |                                                              |
| pageYoffset |                                                              |
| scrollX     |                                                              |
| scrollY     |                                                              |

友情出演windows画图:

![inner](F:\library\article\assets\inner-1556423770365.jpg)

**注意**:单位均为像素.

**注意**:滚动条并不视为浏览器的ui中的内容,而是视为内容区域的一部分,右侧默认的滚动条的宽度包含在window.innerWidth中,但是不属于html元素和html下的任何元素.

window.screen

## iframe嵌套的页面

iframe中也有window对象获取参数的方式是一致的.但是



# 元素部分

## 属性

| 属性名称             | 人类解释                                                     |
| -------------------- | ------------------------------------------------------------ |
| element.clientWidth  | 元素内容区域宽度+padding的宽度,如果宽度溢出且裁剪那么不包含被裁剪掉的部分. |
| element.scrollWidth  | 当子元素宽度溢出,这里提供的是子元素的宽度包括溢出的部分,大小计算和clientWidth一样. |
| element.offsetWidth  | 相当于计算边框宽度的clientWidth,宽度计算为content+padding+border. |
| element.clientHeight | 元素内容区域高度+padding的高度,如果高度溢出且裁剪那么不包含被裁剪掉的部分. |
| element.scrollHeight | 当子元素高度溢出,这里提供的是子元素的高度包括溢出的部分,大小计算和clientHeight一样. |
| element.offsetHeight | 相当于计算边框高度的clientHeight,高度计算为content+padding+border. |
| element.clientLeft   | 元素左边框的宽度                                             |
| element.scrollLeft   | 计算较为复杂,看后续详解                                      |
| element.offsetLeft   | 计算比较复杂,看下面详解                                      |
| element.clientTop    | 元素上边框的宽度                                             |
| element.scrollTop    | 计算较为复杂,看后续详解                                      |
| element.offsetTop    | 计算比较复杂,看下面详解                                      |

## 滚动条的规律

无论是横向滚动条还是纵向滚动条,对于测量clientXXX来元素来说说是不纳入计算的.

例如在下面这张图中,我们测量父元素的clientWidth的结果中是不会包含滚动条的大小的.

![1556424437524](F:\library\article\assets\1556424437524.png)

例如:

```html
<div id="root" style="width: 800px;height: 600px;">
	<div class="inner" style="height:1000px;"></div>
</div>
```

这里例子中子div比父div高,导致**父元素出现了纵向滚动条**,父元素自然不会变宽,宽度还是固定的,但是相对的子元元素的宽度就会变小了.

**而offsetXXX包含了滚动条的大小.**

**所以在`margin:0;padding:0;border-width:0;`情况下`offsetWidth-clientWidth`=滚动条的宽度**.

看来chrome浏览器滚动条大小是17px有没有小数就不知道了.

**scrollXXX的表现和clientXXX一致.**

## 关于box-sizing:border-box

请记住,对于clientXXX来说,**元素的大小就是padding+content.**

而使用border-box后元素的表现就是**padding和border的修改就不会影响到元素的大小.**

**此时width是多少clientWidth就是多少,height同理.**

但是不要忘记了border的大小不列为clientXXX计算的项目,但是border的修改也不会导致元素的大小发生改变.

**那么当border变大,对应的clientXXX就变小.**

一个元素设置了`border-box`:

```css
box{
  width:100px;
  padding:20px;
  border:20px solid;
  box-sizing:border-box;
}
```

此时clientWidth = 100px - 20px*2(左右边框的宽度) = 60px

由于offsetXXX的计算是包含border的大小的,所以如果一个元素设置了`border-box`那么offsetWidth就等于元素的width大小.

## offsetTop和offsetLeft

子元素的`offsetWidth|height`是相对于父元素内容区域(padding+content)左侧和顶部的偏移量.

这个两个是相对值,是要求出向对于父级使用定位情况下来进行计算的,这个父元素可以通过[HTMLElement.offsetParent](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent)来获取到.

例如:父级使用`absolute`或者`relative`.

**注意**后文提出的父元素都指的是使用了定位的父元素.

**注意**:以上都是对于块级元素所描述的,对于行内元素或者td等元素相对的父元素不尽相同,这里不考虑这些情况,详情可以查看上方的链接.

那么对于offsetLeft来说:

| 父元素(定位) | 子元素      |
| ------------ | ----------- |
| padding-left | margin-left |

offsetTop同理.

[在线实例](<https://jsbin.com/mavitiyeso/edit?html,css,js,output>)

**注意**:貌似offsetTop和Left在不同浏览器下有不同计算值,会带来兼容性问题,这里就不展开了,有兴趣的读者可以去查阅相关资料.

## scrollTop和scrollLeft

首先scrollTop和scrollLeft是一对可读写的属性,这意味着你可以获取他的值也可以设置它从而控制滚动的距离.

![scrollTop](F:\library\article\assets\scrollTop.png)

# 方法

### getBoundingClientRect

关于这个方法建议阅读[MDN的指南](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect).当然你也可以选择听我瞎扯几句.

这个api是ie首先提出(早在ie4时候就有了)的这也是ie对web开发的贡献之一.

调用这个api会返回一个[DOMRect](https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect)对象,这个对象多次易名,不过没有变化过基本概念.

当你调用这个方法的时候他会返回一个对象,该对象拥有如下几个属性:

- left
- top
- right
- bottom
- width
- height
- x
- y

**注意**:ie9+包括edge兼容width和height截止到2019年4月5日ie和edge不兼容x和y.

和属性返回的值有两点不同:

- 返回的值都是相对值,相对于浏览器视口的左上角
- 返回的值包含小数部分,这意味着获取到的值更加精确

如何理解:

如果页面中只有一个1000px高100%宽的div(没有margin,padding,border),那它的bottom和height应该1000,left和top是0,right和width是元素宽度:

- 因为我们指定了1000px所以他的height是1000,
  因为页面中只有这一个元素,他的内容区域底部到可视区域顶部的距离就是1000,所以bottom是1000.
- 因为页面中只有这一个元素,所以这个元素是贴着可视区域的顶端和左侧的,所以left和top这两个值都是0.
- div默认会铺满横向的空间,横向空间中只有我们的div所以right到视口区域左侧的距离就是元素的宽度,也是当前可视区域的宽度.

**注意**:left,right,top,bottom指的是内容区域的边缘到视口左上角的距离,不包括border和margin,padding,如果指定了`box-sizing:border-box;`则也包括border和padding.

**但是,由于是该对象的值是相对值,而视口是会移动的,所以top和left的值在视口移动后会发生改变.**

图解:

![1554458753806](F:\library\article\assets\1554458753806.png)

**注意**:该属性返回的值也将滚动条视为宽度(纵向)和高度(横向)的一部分.

和getBoundingClientRect类似的还有另外一个api叫做[getClientRects](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects).这个api作用起来稍微复杂一些,简单的作用于内联元素的时候两者有区别,首先它返回的是数组,包含这个内联元素所有行的DOMRect对象,当内联元素只有一行的时候这两个api表现一样的.

>关于getClientRects的讨论
>
>https://segmentfault.com/q/1010000002559120

