# 前言

在web技术发展飞速的时代,技术更新日新月异.为了完成任务使用高阶框架和类库的堆砌早已成了家常便饭.  

有趣的是当自己需要完成某些简单的任务而操作DOM的时候,居然发现无从下手.

这次的问题是,如何获取浏览器的视窗大小,和元素的宽高.

这个问题看似简单,实则不然.当然结果是简单的,但是想要搞懂的过程还是较为不易的.

浏览器并没有直接提供一个简单的属性就告诉你浏览器窗口的大小,或者一个元素的宽高.

为什么?

就拿div元素来举例,我们有很多的问题影响到了元素宽高:
- border 是否纳入宽高的计算?
- padding 是否纳入宽高的计算?
- magin 是否纳入宽高的计算?
- box-sizing:border-box; 时候该如何计算?
- 父元素使用了overflow:hidden;把我们的元素裁剪了,这时候的宽高该如何计算?
- 元素使用了overflow出现了滚动条此时该如何计算?

而如果要获取一个浏览器窗口的大小,你还要面对我们到底是要获取哪个大小?
- 屏幕大小?
- 浏览窗口大小?
- 浏览区域大小?
- 是否包含滚动条?

当然最终你还要面临一个兼容问题,致敬我们敬爱的IE浏览器,不过本文可不探讨浏览器之间的差异.不过本文的涉及到的内容应该在IE9以上都是可以正常使用的.

# 浏览器部分

浏览器的宽高计算主要通过window对象来完成.

这个对象上提供了几个属性:
- window.innerWidth 
- window.innerHeight 
- window.outerWidth 
- window.outerHeight

用人类语言来描述这几个属性就是.

| 属性名称    | 人类解释                                                     |
| ----------- | ------------------------------------------------------------ |
| innerWidth  | 获取页面可视区域的宽度包括右侧的滚动条(如果有的话).<br />所谓的可视区域就是HTML页面的内容区域不包括浏览器自身的ui所占用的空间(地址栏和菜单栏等). |
| innerHeight | 获取页面可视区域的高度包括底部的滚动条(如果有的话).<br />解释同上. |
| outerWidth  | 获取浏览器宽度.<br />这个十分好理解就是浏览器的宽度,这个宽度中包含了浏览器窗口所占的宽度. |
| outerHeight | 获取浏览器高度.<br />解释同上.                               |
| pageXoffset | 相对于视口的左侧返回当前窗口水平方向移动的距离,在现代浏览器上该值可能返回一个双精度浮点型 |
| pageYoffset | 相对于视口的顶部返回当前窗口垂直方向移动的距离,在现代浏览器上该值可能返回一个双精度浮点型 |
| scrollX     | 同pageXoffset                                                |
| scrollY     | 同pageYoffset                                                |

> MDN滚动参数兼容性参考
>
> https://developer.mozilla.org/zh-CN/docs/Web/API/Window/scrollY#Notes

另外有关滚动的请看最后一节.

友情出演windows画图:

![inner](F:\library\article\assets\inner-1556423770365.jpg)

**注意**:单位均为像素.

**注意**:滚动条并不视为浏览器的ui中的内容,而是视为内容区域的一部分,右侧默认的滚动条的宽度包含在`window.innerWidth`中,但是不属于html元素和html下的任何元素.

# 元素部分

## 属性

| 属性名称             | 人类解释                                                     |
| -------------------- | ------------------------------------------------------------ |
| element.clientWidth  | 元素内容区域宽度+padding的宽度,如果宽度溢出且裁剪那么不包含被裁剪掉的部分. |
| element.scrollWidth  | 当子元素宽度溢出,这里提供的是子元素的宽度包括溢出的部分,大小计算和clientWidth一样. |
| element.offsetWidth  | 相当于计算边框宽度的clientWidth,宽度计算为content+padding+border. |
| element.clientHeight | 元素内容区域高度+padding的高度,如果高度溢出且裁剪那么不包含被裁剪掉的部分. |
| element.scrollHeight | 当子元素高度溢出,这里提供的是子元素的高度包括溢出的部分,大小计算和clientHeight一样. |
| element.offsetHeight | 相当于计算边框高度的clientHeight,高度计算为content+padding+border. |
| element.clientLeft   | 元素左边框的宽度                                             |
| element.scrollLeft   | 计算较为复杂,看后续详解                                      |
| element.offsetLeft   | 计算比较复杂,看下面详解                                      |
| element.clientTop    | 元素上边框的宽度                                             |
| element.scrollTop    | 计算较为复杂,看后续详解                                      |
| element.offsetTop    | 计算比较复杂,看下面详解                                      |

## 滚动条的规律

无论是横向滚动条还是纵向滚动条,对于测量`clientXXX`这个单位来说是不包括滚动条的宽(高)的.

例如在下面这张图中我们进行测量父元素(黑色区域)的`clientWidth`结果和子元素(红色区域)的`clientWidth`的大小是一样的.

不过需要注意的是,一旦出现了滚动条对于`clientWidth`来说就意味着宽度减小(高度同理).

![1556424437524](F:\library\article\assets\1556424437524.png)

**而`offsetXXX`包含了滚动条的大小.**

**所以在`margin:0;padding:0;border-width:0;`情况下`offsetWidth - clientWidth`=滚动条的宽度**.

通过这种方式我求出了chrome浏览器滚动条大小是17px整,但是不要忘记这些API只会返回整数.

**注意**:`scrollXXX`对于滚动条计算的规则和`clientXXX`表现一致.

## 涉及到box-sizing:border-box的计算

请记住,对于clientXXX来说,**元素的大小就是padding+content.**

而使用border-box后元素的表现就是**padding和border的修改就不会影响到元素的大小.**

**此时width是多少`clientWidth`就是多少,height同理.**

但是不要忘记了border的大小不列为`clientXXX`计算的项目,但是border的修改并不会影响元素的宽高变化,那么**那么当border变大,对应的`clientXXX`就变小.**

一个元素设置了`border-box`:

```css
box{
  width:100px;
  padding:20px;
  border:20px solid;
  box-sizing:border-box;
}
```

此时`clientWidth`= 100px - 20px*2(左右边框的宽度) = 60px

由于`offsetXXX`的计算是包含border的大小的,所以如果一个元素设置了`border-box`那么`offsetWidth`就等于元素的width大小,因为border被限制到了width中.

## `offsetTop`和`offsetLeft`

子元素的`offsetWidth|height`是相对于父元素内容区域(padding+content)左侧和顶部的偏移量.

这个两个是相对值,是要求出向对于父级使用定位情况下来进行计算的,这个父元素可以通过[HTMLElement.offsetParent](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetParent)来获取到.

**例如**:父级使用`absolute`或者`relative`.

**注意**后文提出的父元素都指的是使用了定位的父元素.

**注意**:以上都是对于块级元素所描述的,对于行内元素或者td等元素相对的父元素不尽相同,这里不考虑这些情况,详情可以查看上方的链接.

### 情况1

![1557211244947](F:\library\article\assets\1557211244947.png)

在子元素使用了绝对定位的情况下,父元素无法干预子元素,所以子元素的`scrollLeft`就是`left+margin-left`.

### 情况2

![1557211636870](F:\library\article\assets\1557211636870.png)

第二种情况就是父元素和子元素都使用了相对定位,而相对定位是不脱离文档流的,那么父元素的`padding-left`就会影响到子元素的`scrollLeft`属性.

[在线实例](<https://jsbin.com/mavitiyeso/edit?html,css,js,output>)

**注意**:貌似`offsetTop`和`Left`在不同浏览器下有不同计算值,会带来兼容性问题,这里就不展开了,有兴趣的读者可以去查阅相关资料.

## `scrollTop`和`scrollLeft`

首先scrollTop和scrollLeft是一对可读写的属性,这意味着你可以获取他的值也可以设置它从而控制滚动的距离.

![scrollTop](F:\library\article\assets\scrollTop.png)

**注意**:`scrollTop|scrollLeft`是用在含有滚动区域的元素上(图中黑色边框的元素),而不是被滚动的元素上测量,被滚动的元素`scrollTop`永远是0.

**简单理解**:在垂直方向上含有滚动条的元素的内容区域的顶部(padding+content)相对于自身顶部边框的底部向上移动的距离(水平方向同理).

就是`scrollTop`的大小(图中超出去的部分).

## 方法

### getBoundingClientRect

关于这个方法建议阅读[MDN的指南](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect).当然你也可以选择听我瞎扯几句.

这个api是ie首先提出(早在ie4时候就有了)的这也是ie对web开发的贡献之一.

调用这个api会返回一个[DOMRect](https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect)对象,这个对象多次易名,不过没有变化过基本概念.

当你调用这个方法的时候他会返回一个对象,该对象拥有如下几个属性:

- left
- top
- right
- bottom
- width
- height
- x
- y

**注意**:ie9+包括edge兼容width和height截止到2019年4月5日ie和edge不兼容x和y.

和属性返回的值有两点不同:

- 返回的值都是相对值,相对于浏览器视口的左上角
- 返回的值包含小数部分,这意味着获取到的值更加精确

如何理解:

如果页面中只有一个1000px高100%宽的div(没有margin,padding,border),那它的bottom和height应该1000,left和top是0,right和width是元素宽度:

- 因为我们指定了1000px所以他的height是1000,
  因为页面中只有这一个元素,他的内容区域底部到可视区域顶部的距离就是1000,所以bottom是1000.
- 因为页面中只有这一个元素,所以这个元素是贴着可视区域的顶端和左侧的,所以left和top这两个值都是0.
- div默认会铺满横向的空间,横向空间中只有我们的div所以right到视口区域左侧的距离就是元素的宽度,也是当前可视区域的宽度.

**注意**:left,right,top,bottom指的是内容区域的边缘到视口左上角的距离,不包括border和margin,padding,如果指定了`box-sizing:border-box;`则也包括border和padding.

**但是,由于是该对象的值是相对值,而视口是会移动的,所以top和left的值在视口移动后会发生改变.**

图解:

![1554458753806](F:\library\article\assets\1554458753806.png)

**注意**:该属性返回的值也将滚动条视为宽度(纵向)和高度(横向)的一部分.

和getBoundingClientRect类似的还有另外一个api叫做[getClientRects](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects).这个api作用起来稍微复杂一些,简单的作用于内联元素的时候两者有区别,首先它返回的是数组,包含这个内联元素所有行的DOMRect对象,当内联元素只有一行的时候这两个api表现一样的.

>思否上一篇关于`getClientRects`的讨论
>
>https://segmentfault.com/q/1010000002559120

# 屏幕部分

这部分主要利用`window.screen`对象,这个对象抽象的表示当前使用的物理显示设备.

没错这个属性是和硬件有关的,一般的Web开发中很少会使用这个属性.

通过这个对象你可以获取到有关屏幕的分辨率等信息

这里就不多介绍了,附上一篇介绍详细的文章:

> https://www.cnblogs.com/ndos/p/8245164.html

此外在windows上还有几个关于屏幕的属性:

| 名称       | 描述                             |
| ---------- | -------------------------------- |
| screenLeft | 浏览器窗口左侧到屏幕左边缘的距离 |
| screenTop  | 浏览器窗口顶部到屏幕上边缘的距离 |
| screenX    | 同`screenLeft`                   |
| screenY    | 同`screenTop`                    |

# window滚动

在这节中讨论window上的有关滚动的几个属性和方法.

## `window.scrollBy`

## `window.scrollTo`

## `window.scrollByLines`

## `window.scrollByPages`

## `window.scrollMaxX`

## `window.scrollMaxY`



