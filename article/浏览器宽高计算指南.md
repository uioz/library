# 前言

在web技术发展飞速的时代,技术更新日新月异.为了完成任务使用高阶框架和类库的堆砌早已成了家常便饭.  
有趣的是当自己需要完成某些简单的任务而操作DOM的时候,居然发现无从下手.

这次的问题是,如何获取浏览器的视窗大小,和元素的宽高.

这个问题看似简单,实则不然.当然结果是简单的,但是想要搞懂的过程还是较为不易的.

浏览器并没有直接提供一个简单的属性就告诉你浏览器窗口的大小,或者一个元素的宽高.

为什么?

就拿div元素来举例,我们有很多的问题影响到了元素宽高:
- border 是否纳入宽高的计算?
- padding 是否纳入宽高的计算?
- magin 是否纳入宽高的计算?
- box-sizing:border-box; 时候该如何计算?
- 父元素使用了overflow:hidden;把我们的元素裁剪了,这时候的宽高该如何计算?
- 元素使用了overflow出现了滚动条此时该如何计算?

而如果要获取一个浏览器窗口的大小,你还要面对我们到底是要获取哪个大小?
- 屏幕大小?
- 浏览窗口大小?
- 浏览区域大小?
- 是否包含滚动条?
- 页面中的iframe该如何计算?

当然最终你还要面临一个兼容问题,致敬我们敬爱的IE浏览器,不过本文可不探讨浏览器之间的差异.不过本文的涉及到的内容应该在IE9以上都是可以正常使用的.

# 浏览器部分

浏览器的宽高计算主要通过window对象来完成.

这个对象上提供了几个属性:
- window.innerWidth 
- window.innerHeight 
- window.outerWidth 
- window.outerHeight

用人类语言来描述这几个属性就是.

| 属性名称    | 人类解释                                                     |
| ----------- | ------------------------------------------------------------ |
| innerWidth  | 获取页面可视区域的宽度包括右侧的滚动条(如果有的话).<br />所谓的可视区域就是HTML页面的内容区域不包括浏览器自身的ui所占用的空间(地址栏和菜单栏等). |
| innerHeight | 获取页面可视区域的高度包括底部的滚动条(如果有的话).<br />解释同上. |
| outerWidth  | 获取浏览器宽度.<br />这个十分好理解就是浏览器的宽度,这个宽度中包含了浏览器窗口所占的宽度. |
| outerHeight | 获取浏览器高度.<br />解释同上.                               |

**注意**:单位均为像素.

**注意**:滚动条并不视为浏览器的ui中的内容,而是视为内容区域的一部分.一般来说你获取到的内容区域的宽度都大于实际的元素宽度,因为innerWidth是算上了在右边的纵向滚动条的宽度的,当页面出现垂直滚动条的时候你可以使用调试工具选择body元素来证明这一点,body元素的宽度要小于innerWidth的值.

window.screen

pageXOffset

screenTop

screenX

scrollTop

## iframe嵌套的页面

iframe中也有window对象获取参数的方式是一致的.但是



# 元素部分

## 属性

| 属性名称             | 人类解释                                                     |
| -------------------- | ------------------------------------------------------------ |
| element.clientWidth  | 元素内容区域宽度+padding的宽度,如果宽度溢出且裁剪那么不包含被裁剪掉的部分. |
| element.scrollWidth  |                                                              |
| element.offsetWidth  | 相当于计算边框宽度的clientWidth,宽度计算为content+padding+border. |
| element.clientHeight | 元素内容区域高度+padding的高度,如果高度溢出且裁剪那么不包含被裁剪掉的部分. |
| element.scrollHeight |                                                              |
| element.offsetHeight | 相当于计算边框高度的clientHeight,高度计算为content+padding+border. |
| element.clientLeft   | 元素左边框的宽度                                             |
| element.scrollLeft   |                                                              |
| element.offsetLeft   | 计算比较复杂,看下面详解                                      |
| element.clientTop    | 元素上边框的宽度                                             |
| element.scrollTop    |                                                              |
| element.offsetTop    | 计算比较复杂,看下面详解                                      |

## 滚动条的规律

无论是横向滚动条还是纵向滚动条,滚动条的宽高是属于拥有滚动条的元素的.

例如:

```html
<div id="root" style="width: 800px;height: 600px;">
	<div class="inner" style="height:1000px;"></div>
</div>
```

这里例子中子div比父div高,导致**父元素出现了纵向滚动条**,父元素自然不会变宽,宽度还是固定的,但是相对的子元元素的宽度就会变小了.

所以一个元素的宽度中是包含了滚动条的宽度的,但是相对的子元素就会被滚动条占用一些空间,导致子元素变小.

## 关于box-sizing:border-box

请记住,对于clientXXX来说,**元素的大小就是**padding+content.

当使用了border-box后元素的padding和border的修改就不会影响到元素的大小,此时width是多少clientWidth就是多少,heigh同理.

但是不要忘记了border的大小不列为计算的项目,但是border的修改也不会导致元素的大小发生改变.

那么当border变大,对应的clientXXX就变小.

一个元素设置了`border-box`:

```css
box{
  width:100px;
  padding:20px;
  border:20px solid;
  box-sizing:border-box;
}
```

此时clientWidth = 100px - 20px*2(左右边框的宽度) = 60px

由于offsetXXX的计算是包含border的大小的,所以如果一个元素设置了`border-box`那么offsetWidth就等于元素的width大小.

## offsetTop和offsetLeft

这个两个是相对值,是要求出向对于父级使用定位情况下来进行计算的,父级使用`absolute`或者`relative`,**注意**后文提出的父元素都指的是使用了定位的父元素.

那么对于offsetLeft来说:

| 父元素                               | 子元素      |
| ------------------------------------ | ----------- |
| margin-left+border-left+padding-left | margin-left |

offsetTop同理.

实际上这就是父元素内容区域的偏移量加上自身非offsetXXX区域的偏移量.

## 方法

### getBoundingClientRect

关于这个方法建议阅读[MDN的指南](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect).当然你也可以选择听我瞎扯几句.

这个api是ie首先提出(早在ie4时候就有了)的这也是ie对web开发的贡献之一.

调用这个api会返回一个[DOMRect](https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect)对象,这个对象多次易名,不过没有变化过基本概念.

当你调用这个方法的时候他会返回一个对象,该对象拥有如下几个属性:

- left
- top
- right
- bottom
- width
- height
- x
- y

**注意**:ie9+包括edge兼容width和height截止到2019年4月5日ie和edge不兼容x和y.

和属性返回的值有两点不同:

- 返回的值都是相对值,相对于浏览器视口的左上角
- 返回的值包含小数部分,这意味着获取到的值更加精确

如何理解:

如果页面中只有一个1000px高100%宽的div(没有margin,padding,border),那它的bottom和height应该1000,left和top是0,right和width是元素宽度:

- 因为我们指定了1000px所以他的height是1000,
  因为页面中只有这一个元素,他的内容区域底部到可视区域顶部的距离就是1000,所以bottom是1000.
- 因为页面中只有这一个元素,所以这个元素是贴着可视区域的顶端和左侧的,所以left和top这两个值都是0.
- div默认会铺满横向的空间,横向空间中只有我们的div所以right到视口区域左侧的距离就是元素的宽度,也是当前可视区域的宽度.

**注意**:left,right,top,bottom指的是内容区域的边缘到视口左上角的距离,不包括border和margin,padding,如果指定了`box-sizing:border-box;`则也包括border和padding.

**但是,由于是该对象的值是相对值,而视口是会移动的,所以top和left的值在视口移动后会发生改变.**

图解:

![1554458753806](F:\library\article\assets\1554458753806.png)

所以如果不考虑精度问题则`bottom-top === height` ,`right-left === width`.

**注意**:该属性返回的值也将滚动条视为宽度(纵向)和高度(横向)的一部分.

和getBoundingClientRect类似的还有另外一个api叫做[getClientRects](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects).这个api作用起来稍微复杂一些,简单的作用于内联元素的时候两者有区别,首先它返回的是数组,包含这个内联元素所有行的DOMRect对象,当内联元素只有一行的时候这两个api表现一样的.

>思否上的一篇讨论关于getClientRects
>
>https://segmentfault.com/q/1010000002559120

