# 前言

在web技术发展飞速的时代,技术更新日新月异.为了完成任务使用高阶框架和类库的堆砌早已成了家常便饭.  
有趣的是当自己需要完成某些简单的任务而操作DOM的时候,居然发现无从下手.

这次的问题是,如何获取浏览器的视窗大小,和元素的宽高.

这个问题看似简单,实则不然.当然结果是简单的,但是想要搞懂的过程还是较为不易的.

浏览器并没有直接提供一个简单的属性就告诉你浏览器窗口的大小,或者一个元素的宽高.

为什么?

就拿div元素来举例,我们有很多的问题影响到了元素宽高:
- border 是否纳入宽高的计算?
- padding 是否纳入宽高的计算?
- magin 是否纳入宽高的计算?
- box-sizing:border-box; 时候该如何计算
- 父元素使用了overflow:hidden;把我们的元素裁剪了,这时候的宽高该如何计算
- 自己使用了overflow出现了滚动条此时该如何计算

而如果要获取一个浏览器窗口的大小,你还要面对我们到底是要获取哪个大小?
- 屏幕大小?
- 浏览窗口大小?
- 浏览区域大小?
- 是否包含滚动条?
- 页面中的iframe该如何计算?

当然最终你还要面临一个兼容问题,致敬我们敬爱的IE浏览器,不过本文可不探讨浏览器之间的差异.本文的涉及到的内容应该在IE9以上都是可以正常使用的.

# 浏览器部分

浏览器的宽高计算主要通过window对象来完成.

这个对象上提供了几个属性:
- window.innerWidth 
- window.innerHeight 
- window.outerWidth 
- window.outerHeight

用人类语言来描述这几个属性就是.

| 属性名称    | 人类解释                                                     |
| ----------- | ------------------------------------------------------------ |
| innerWidth  | 获取页面可视区域的宽度包括右侧的滚动条(如果有的话).<br />所谓的可是区域就是页面的内容区域不包括浏览器自身的ui所占用的空间,例如地址栏和菜单栏. |
| innerHeight | 获取页面可视区域的高度包括底部的滚动条(如果有的话).<br />解释同上. |
| outerWidth  | 获取浏览器宽度.<br />这个十分好理解就是浏览器的宽度,这个宽度中包含了浏览器的ui所占的宽度. |
| outerHeight | 获取浏览器高度.<br />解释同上.                               |

**注意**:单位均为像素.

**注意**:滚动条并不视为浏览器的ui中的内容,而是视为内容区域的一部分.一般来说你获取到的内容区域的宽度都大于实际的元素宽度,因为innerWidth是算上了在右边的纵向滚动条的宽度的,当页面出现垂直滚动条的时候你可以使用调试工具选择body元素来证明这一点,body元素的宽度要小于innerWidth的值.

window.screen

pageXOffset

screenTop

screenX

scrollTop

## iframe嵌套的页面

iframe中也有window对象获取参数的方式是一致的.但是



# 元素部分

## 属性

| 属性名称             | 人类解释                                                     |
| -------------------- | ------------------------------------------------------------ |
| element.clientWidth  | 元素可视区域宽度和padding的宽度包括滚动条的宽度(如果高度溢出且没有裁剪),元素被裁剪则显示裁剪后的宽度. |
| element.scrollWidth  |                                                              |
| element.offsetWidth  | 元素不包含margin的宽度,如果有滚动条则也被计算在内,如果元素被裁剪它依然表示元素裁剪前的宽度. |
| element.clientHeight | 元素可视区域高度和padding的高度包括滚动条的宽度(如果宽度溢出且没有裁剪),元素被裁剪则显示裁剪后的宽度. |
| element.scrollHeight |                                                              |
| element.offsetHeight | 元素不包含margin的高度,如果有滚动条则也被计算在内,如果元素被裁剪它依然表示元素裁剪前的高度 |
| element.clientLeft   | 元素左边框的宽度,不计算右边框                                |
| element.scrollLeft   |                                                              |
| element.offsetLeft   |                                                              |
| element.clientTop    | 元素上边框的宽度,不计算底边框                                |
| element.scrollTop    |                                                              |
| element.offsetTop    |                                                              |

**注意**:

1. clientWidth和Height会受到`box-sizing:border-box`的影响,具体值的表现和css一致,使用`border-box`元素添加padding不会影响宽高,但是如果修改border会影响元素大小,border越大元素越小.
2. clientLeft和Top不受margin和padding还有`border-box`的影响.
3. offsetWidth和Height不受`border-box`的影响
4. 

## 方法

### getBoundingClientRect

关于这个方法建议阅读[MDN的指南](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect).当然你也可以选择听我瞎扯几句.

这个api是ie首先提出(早在ie4时候就有了)的这也是ie对web开发的贡献之一.

调用这个api会返回一个[DOMRect](https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect)对象,这个对象多次易名,不过没有变化过基本概念.

当你调用这个方法的时候他会返回一个对象,该对象拥有如下几个属性:

- left
- top
- right
- bottom
- width
- height
- x
- y

**注意**:ie9+包括edge兼容width和height截止到2019年4月5日ie和edge不兼容x和y.

和属性返回的值有两点不同:

- 返回的值都是相对值,相对于浏览器视口的左上角
- 返回的值包含小数部分,这意味着获取到的值更加精确

如何理解:

如果页面中只有一个1000px高100%宽的div(没有margin,padding,border),那它的bottom和height应该1000,left和top是0,right和width是元素宽度:

- 因为我们指定了1000px所以他的height是1000,
  因为页面中只有这一个元素,他的内容区域底部到可视区域顶部的距离就是1000,所以bottom是1000.
- 因为页面中只有这一个元素,所以这个元素是贴着可视区域的顶端和左侧的,所以left和top这两个值都是0.
- div默认会铺满横向的空间,横向空间中只有我们的div所以right到视口区域左侧的距离就是元素的宽度,也是当前可视区域的宽度.

**注意**:left,right,top,bottom指的是内容区域的边缘到视口左上角的距离,不包括border和margin,padding,如果指定了`box-sizing:border-box;`则也包括border和padding.

**但是,由于是该对象的值是相对值,而视口是会移动的,所以top和left的值在视口移动后会发生改变.**

图解:

![1554458753806](F:\library\article\assets\1554458753806.png)

所以如果不考虑精度问题则`bottom-top === height` ,`right-left === width`.

**注意**:该属性返回的值也将滚动条视为宽度(纵向)和高度(横向)的一部分.

和getBoundingClientRect类似的还有另外一个api叫做[getClientRects](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects).这个api作用起来稍微复杂一些,简单的作用于内联元素的时候两者有区别,首先它返回的是数组,包含这个内联元素所有行的DOMRect对象,当内联元素只有一行的时候这两个api表现一样的.

>思否上的一篇讨论关于getClientRects
>
>https://segmentfault.com/q/1010000002559120

