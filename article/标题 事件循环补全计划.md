# 标题: 事件循环补全计划

# 前言

事件循环(event loop)是一个在 JavaScript 常被提起的概念, 它存在于浏览器也存在于 Node.js 中, 因为它复杂的运行机制和变幻莫测的行为令人难以琢磨, 更是成为面试时候的必考题目.

在本篇文章中将会总结 "事件循环" 这个概念, 无论是浏览器端还是 Node.js 端都会涉及.

为了尽可能的减少错误, 本篇文章的信息来源基于 "官方文档" 以及 "规范" 和 历届 jsconf 大会上的有关 "事件循环" 的演讲, 本篇文章实际上就是把这些内容总结到了一起的结果, 你可以在文章的末尾获取这些内容源地址.



# 初探事件循环

> https://youtu.be/8aGhZQkoFbQ



我们先从浏览器开始, 因为大部分从事 Node.js 开发的大多数人或多或少都了解浏览器中的事件循环的基本概念.

## JavaScript运行的基本流程

我们都知道JavaScript是一个单线程的编程语言, 这意味着它只能有一个调用栈, 执行过程中每次只能做一件事情.

为了充分理解, 我们来例举一个简单的例子:

```javascript
function fun1() {
  return 'fun1'
}

function fun2() {
  return 'fun2' + fun1();
}

function fun3() {
  console.log(fun2());
}

fun3();
```

一旦代码执行调用栈中函数压入的顺序如下:

```
+----------+ +----------+ +----------+
|    stack | |    stack | |    stack |
|          | |          | |          |
|          | |          | |          |
|          | |          | | +------+ |
|          | |          | | | fun3 | |
|          | |          | | +------+ |
|          | |          | |          |
|          | | +------+ | | +------+ |
|          | | | fun2 | | | | fun2 | |
|          | | +------+ | | +------+ |
|          | |          | |          |
| +------+ | | +------+ | | +------+ |
| | fun1 | | | | fun1 | | | | fun1 | |
| +------+ | | +------+ | | +------+ |
|          | |          | |          |
+----------+ +----------+ +----------+
```

位于栈顶的函数(fun3)执行完成后调用栈会把他弹出:

```
+----------+ +----------+ +----------+
|    stack | |    stack | |    stack |
|          | |          | |          |
|          | |          | |          |
|          | |          | |          |
|   💥     | |          | |          |
|          | |          | |          |
|          | |          | |          |
| +------+ | |          | |          |
| | fun2 | | |    💥    | |          |
| +------+ | |          | |          |
|          | |          | |          |
| +------+ | | +------+ | |          |
| | fun1 | | | | fun1 | | |    ✨    |
| +------+ | | +------+ | |          |
|          | |          | |          |
+----------+ +----------+ +----------+
```

调用栈被JavaScript引擎使用和监视, 所以当我们在函数中抛出了一个错误但是没有对应的 `try/catch` 语句的时候:

```javascript
function fun1() {
  throw new Error('Warning: Nuclear Missile Launched') // 抛出一个错误但是没有对于的 try/catch 语句
}

function fun2() {
  return 'fun2' + fun1();
}

function fun3() {
  console.log(fun2());
}

fun3();
```

可以在控制台中的报错中看到调用栈的信息:

![1566047594418](C:\Users\zhao\Documents\library\article\assets\1566047594418.png)

但是调用栈也是脆弱的如果我们创建一个无法中断调用函数, 那么调用栈会瞬间爆炸💥这种行为被称为 "栈溢出". 可喜可贺的是JavaScript会监视调用栈, 一旦调用栈出现 "栈溢出" JavaScript 会终止代码的执行并且抛出错误:

```javascript
function foobar() {
	foobar();
}

foobar();
```

抛出 "栈溢出" 错误:

![1566048013705](C:\Users\zhao\Documents\library\article\assets\1566048013705.png)

## 阻塞的坏处

在 Web 开发中我们经常要会听到要避免浏览器阻塞, "阻塞" 听起来有点像我们常说的 "电脑卡住了" 中的 "卡住".

实际上阻塞并没有一个严格的定义, JavaScript 的运行速度是很快的, 执行几个简单的 "console.log" 你无法体会到这其中所花费的时间, 如果调用栈中正在执行的函数花费了大量的时间, 我们感觉浏览器被卡住了, 体验不流畅此时我们说, 浏览器被阻塞了.

但是浏览器不仅仅执行 JavaScript 代码还会异步的加载外部资源文件, 这些加载的流程也可以被 JavaScript 所控制, 例如我们通过 JavaScript 发起一个同步的网络请求:

```javascript
var oReq = new XMLHttpRequest();
oReq.onload = function(){};
oReq.open("get", "https://xxx.com/", false); // false 表示同步发送请求(这种方式已经不在被推荐使用仅仅用于示例)
oReq.send();
alert('running!'); // 只有请求完成后 alert 才会执行
```

这个请求有可能需要 20ms 或者 300ms 甚至更长, 在请求的过程中浏览器会一直等待请求完成甚至会停止页面的渲染, 我们可以明显的感受到浏览器卡住了, 这是典型的阻塞.

## 异步回调

浏览器将所有可能花费大量时间等待的操作都提供了对应的异步接口, 这种解决方式被称为 "异步函数" 或者 "回调函数" 或者 "异步回调" 等.

一个典型的例子如下:

```javascript
console.log('hello');

setTimeout(function foobar(){
    console.log('delay');
},1000);

console.log('world');
```

我们都知道这段代码会输出的顺序是:

1. hello
2. world
3. delay

那么浏览器到底是如何解释这段代码的呢, 我们可以观察浏览器的调用栈:

```
console.log('hello'); // 压入栈中执行
console.log('hello'); // 执行完成栈弹出

setTimeout            // 压入栈中执行
setTimeout            // 执行完成栈弹出

console.log('world'); // 压入栈中执行
console.log('world'); // 执行完成栈弹出

-------1000ms过后------

foobar                // 压入栈中执行
console.log('delay'); // 压入栈中执行
console.log('delay'); // 执行完成弹出
foobar                // 执行完成弹出

```

最神奇的事情出现了 `setTimeout` 执行完成后就被调用栈弹出了, 但是不知何故 1000ms 后 `setTimeout` 中的 `foobar` 被神奇的唤醒了, 这是怎么回事?

## 题外话 webapi

在 JavaScript 中执行元素绑定事件, 使用 `setTimeout` 设置一个延时执行, 或者发起一次网络请求. 这些都是web开发者的家常便饭, 对于我们来说这些内容就是 JavaScript 的一部分了, 但是实际上这些内容并没有在 ECMAScript 制定的标准中, 包括我们讨论的 "事件循环" 机制它也没有存在于规范中也就是说这个机制是独立于 JavaScript 引擎的功能.

这些API被称为 `webapi` 它们有自己的规范和实现与 JavaScript 这门语言没有关系, 在这份来自于MDN的[页面上](https://developer.mozilla.org/zh-CN/docs/Web/API)列举了所有的API.

## 基本事件循环

我们之前提到了 JavaScript 由于其单线程的特性只能在同一时间执行同一间事情, 这是正确的, 但是浏览器不仅仅拥有解释 JavaScript 脚本的引擎, 还有一堆其他的程序来处理诸如 `DOM` `XmlHttpRequest` `setTimeout` 这些任务.

这些程序各司其职完成自己负责的部分, 它们是独立于 JavaScript 引擎之外的内容, 这些程序可能运行在独立线程上或者进程上它们通过`webapi` 来和 JavaScript引擎进行通信, 所以我们需要通过 "回调" 的方式进行异步编程.

而 **事件循环** 用于管理这些异步任务在合适的时机执行.

`setTimeout` 作为 `webapi` 典型的例子, 我们来观察一下它是如何运行的, 首先 `setTimeout` 一旦被执行便将函数钩子移交给对应的 `webapi` 并且开始计时:

```
+--------------------------------+     +---------------------+
|                                |     |webapis              |
|                                |     | +----------------+  |
| setTimeout(function foobar() { |     | |                |  |
| 	console.log('delay')         | +-> | | timer-0 -- cb()|  |
| },0);                          |     | |                |  |
|                                |     | +----------------+  |
|                                |     |                     |
+--------------------------------+     +---------------------+
```

由于我们的倒计时是0, 所以计时会立即完成, `webapi` 将函数钩子移交给 **任务队列** .

```
+--------------------------------+     +----------+
|                                |     |webapis   |
|                                |     |          |
| setTimeout(function foobar() { |     |          |
| 	console.log('delay')         |     |          | +-+
| },0);                          |     |          |   |
|                                |     |          |   |
|                                |     |          |   |
+--------------------------------+     +----------+   |
                                                      |
+-------------------------------------------------+   |
|                               task queue        |   |
| +--------------+                                |   |
| |              |                                |   |
| |    cb()      |                                | <-+
| |              |                                |
| +--------------+                                |
|                                                 |
+-------------------------------------------------+

```

接下来终于轮到 **事件循环** 上场了, 事件循环完成一件非常简单的工作, 它判断如果:

1. 调用栈是空的
2. 任务队列中存在着任务

那么就将这个任务移入到调用栈中执行:

```
+--------------------------------+ +------------------+
|                                | |           stack  |
|                                | | +--------------+ |
| setTimeout(function foobar() { | | |              | |
| 	console.log('delay')         | | |  cb - foobar | |
| },0);                          | | |              | |
|                                | | +--------+-----+ |
|                                | |          ^       |
+--------------------------------+ |          |       |
event loop ⏳                      |          |       |
+----+---------------------------+ |          |       |
|    |                           | |          |       |
|    |                           | |          |       |
|    +-- task ------> push -------------------+       |
|                                | |                  |
+--------------------------------+ +------------------+

```

然后往复循环这个过程, 这就是事件循环的基本流程.

现在我们来提出一个 `ajax` 的例子, 尝试一下你能说出他的执行流程吗:

```javascript
console.log('hello');

$.get('https:www.google.com',function foobar(){ console.log('callback') });

console.log('world');
```

他的执行流程如下:

1. console.log('hello') --> 压入调用栈中执行
2. console.log('hello') --> 执行完成弹出调用栈
3. $.get --> 压入栈中执行
4. $.get --> 调用了 `webapi` 中的 `XHR` 发起了网络请求, 并保存其函数钩子
5. $.get --> 执行完成弹出调用栈
6. console.log('world') --> 压入调用栈中执行
7. console.log('world') --> 执行完成弹出调用栈
8. 网络请求完成 `webapi` 将函数钩子移动到任务队列中
9. 事件循环--> 检查调用栈是否为空 检查任务队列中是否有任务 (事件循环一直存在并非在只在此刻进行检查)
   1. 调用栈为空
   2. 检查到请求任务
   3. 将该任务(foobar函数)压入到调用栈中
10. console.log('callback') --> 压入调用栈中执行
11. console.log('callback') --> 执行完成弹出调用栈
12. foobar --> 执行完成弹出调用栈
13. 调用栈再次清空

# 事件循环如何影响渲染

> https://youtu.be/cCOL7MC4Pl0

在上一节中我们提到了 JavaScript 是单线程的如果花费大量的时间运行 JavaScript 那么就会阻塞浏览器, 导致浏览器无法完成其他工作, 并且初次了解了 "事件循环" 是如何解决问题的. 在这一节中我们会更加深入, 探讨 "事件循环" 是如何影响渲染.

实际上事件循环的作用范围可能超乎你的想象, 举个例子所有的DOM事件实际上都是受到了 "事件循环" 控制的, 除此以外还包括包括网络请求, IO操作等等这些常见的功能. 因为在背后这些事件的触发者实际上都是将与事件有关的信息放入到了 "任务队列" 中真正让这些内容被执行的实际上是 "事件循环", 还记得 "事件循环" 是如何工作的吗? 通过以下的两个判断, "事件循环" 会将最近的任务移送到 "调用栈" 中:

1. 任务队列中含有任务
2. 调用栈为空

但是浏览器中不仅仅执行 JavaScript 代码还会处理页面渲染, 我们知道如果进行大量的 JavaScript 计算那么浏览器会停止渲染这里面到底隐藏着何种的基情关系? 我们先来了解一下基本的渲染概念.

## 基本的渲染

我们在页面中动态的修改样式界面会进行实时反应, 所以我们认为这些操作是同步的操作, 但是实际上浏览器在背后进行了优化, 重复多此的样式操作会被进行合并然后由浏览器决定一个合适的时机然后统一更新: 

```javascript
element.style.transition = "transform 1s";
element.style.transform = "translateX(100px)";
element.style.transform = "translateX(500px)";
```

应用了样式的元素并不会横向在 100px 和 500px 之间来回移动而是直接移动到了 500px, 浏览器抛弃了旧的无用的样式修改.

所以说修改样式并不是同步的, 浏览器的优化带来的异步的更新机制导致它和 "事件循环" 之间产生关联, 在了解这些关联前我们先来了解一下浏览器的基本渲染机制.

元素样式决定渲染的结果, 从一堆代码转为可视化的界面经历了许多环节, 这里我们来简单的了解一下其中的几个关键步骤:

1. 计算样式 - 收集 css 计算应用到每个元素上的样式
2. 布局 - 确定页面上的元素的位置层叠关系
3. 绘制 - 创建实际的像素绘制到页面上

## 被动的渲染

在下面的这个例子中使用了一个 `video` 来表示页面进行动态的持续的页面渲染, 这些嵌入的内容可以在不受 JavaScript 的干扰下影响页面的显示, 当点击按钮的时候 JavaScript 进入死循环:

```javascript
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>test</title>
</head>
<body>
  <video src="https://vjs.zencdn.net/v/oceans.mp4" controls autoplay></video>
  <button id="button">while true</button>
  <script>
    document.getElementById('button').addEventListener('click',()=>{
      while(true);
    });
  </script>
</body>
</html>
```

当我们点击了按钮的时候:

1. click 事件被放入到了任务队列中
2. 事件循环将click 事件压入调用栈
3. `while true` 执行

此时渲染工作在等待 JavaScript 执行完成, 但是 JavaScript 进入了无限循环中所以渲染工作就一直在等待中永远不会得到完成.

解释这种行为的一个好的方式就是: **我们不妨把页面的渲染过程也视为 "任务队列" 中的一个任务, 这个任务的创建者就是浏览器本身,它在一个合适的时机把渲染任务放入到任务队列中等待执行, 但是由于代码阻塞导致页面无法及时更新.**

// TODO 有待证实

但是实际的情况要更为复杂一些 "任务队列" 实际上有多个, 渲染是一个复杂的过程它有自己的任务队列, 但是任务队列中的任务执行顺序依然是通过 "事件循环" 来决定的, 所以之前提到的理解方式并没有太大的问题.

## 思考

下列代码会造成阻塞吗:

```javascript
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>test</title>
</head>
<body>
  <video src="https://vjs.zencdn.net/v/oceans.mp4" controls autoplay></video>
  <button id="button">while true</button>
  <script>
    function loop(){
      setTimeout(loop,0);
    }
    loop();
  </script>
</body>
</html>
```

这段代码不仅不会造成阻塞甚至不会造成栈溢出, 每次调用 `loop` 函数会向 "任务队列" 添加一个任务然后 `loop` 就会被弹出调用栈, 此时的调用栈就被清空了, 而负责控制任务队列的事件循环只有在调用栈为空的时候才能继续执行任务, 也就是说调用栈永远不会累加.

其次任务的执行并不影向任务队列添加内容, 在调用 `setTimeout(loop,0)` 后 "事件循环" 继续工作处理那些已经被填入到任务队列中在此之前的填入的其他事件以及页面的渲染, 直到 "任务队列" 中再次执行有关 `loop` 的任务.

## 流畅的渲染

试想一下你在页面上制作了一个动画效果使用如下代码:

```javascript
function animate(){
  // 修改样式
}

setInterval(animate,1000/60);
```

你希望动画可以达到 60fps 所以向 `setInterval` 传入了 `1000/60` 期待它可以每秒执行 60 次动画函数.

但是由于 `setInterval` 并不精确在一帧中可能执行了多此, 也可能一次也没有执行, 或者执行了一个耗时的任务导致浏览器无法在一帧中进行渲染操作.

我们希望每一帧中至少有一次渲染过程, 但是任务的执行是随机的任务执行会打乱原有规律的渲染过程:

![1566277658471](C:\Users\zhao\Documents\library\article\assets\1566277658471.png)

而浏览器本身的渲染实际上是非常智能和节约计算的, 例如页面渲染频率自动和屏幕刷新率调整到一致, 当页面静止或者不可视的时候页面会停止渲染, 而使用 `setInterval` 等很难完美的和页面渲染过程相结合.

一个解决问题的办法就是使用 `requestAnimationFrame`.

> **window.requestAnimationFrame()** 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画

使用 `requestAnimationFrame` 我们可以使用浏览器的渲染逻辑将原本杂乱的渲染过程变得有序起来, 让浏览器决定何时进行渲染, 对于动画渲染这再好不过了, 现在有关动画的任务都被排列到了渲染任务的前面:

![1566279040998](C:\Users\zhao\Documents\library\article\assets\1566279040998.png)

## 微任务 (micro task)

微任务是一个复杂的概念很多人不理解其行为, 我们从微任务的设计目的上来解释微任务的工作原理.

很久前W3C给浏览器制定了一些API, 这些API用于监听DOM的变化:

```javascript
element.addEventListener("DOMNodeInserted", function (ev) {
  // ...
}, false);
```

但是这个API有着严重的性能问题, 只要修改元素的属性对应的事件就会被触发, 对同一个属性修改100次就会触发100次的事件, 另外事件具有冒泡的特性子元素的修改也会导致父元素触发该事件:

```javascript
let i = 100;
while(i--){
  const span = document.createElement('span');
  element.appendChild(span); // 触发事件一次
  span.textContent = 'Test'; // 再次触发事件一次
}
```

结果就是无论你在 `DOMNodeInserted` 回调中写多么简单的代码, 复杂的DOM操作导致事件就会被密集调用大大降低性能, 所以这个API被废弃了.

监听DOM修改的需求依然存在, 但是我们希望这个接口的表现就和渲染一样将DOM修改进行合并后只触发一次, 这个规范在DOM3中被推出他就是 [`MutationObserver`](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver), 从而引入了 "微任务" 和 "微任务队列" 这个概念.

微任务是异步的我们用个 `Promise` 来举例:

```javascript
Promise.resolve().then(()=>console.log('hello world'));
console.log('foobar');
```

输出:

```
foobar
hello world
```

`foobar` 先于 `hello world` 输出这点证明了它. 虽然他是异步的但这不代表他必须遵循 "事件循环" 和 "渲染" 制定的规则. 相反 "微任务" 有自己的玩法.

一个典型的特征就是**只有微任务队列清空后微任务才算执行完成**, 我们把之前的 "事件循环" 例子改为微任务版本:

```javascript
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>test</title>
</head>
<body>
  <video src="https://vjs.zencdn.net/v/oceans.mp4" controls autoplay></video>
  <button id="button">while true</button>
  <script>
    document.getElementById('button').addEventListener('click',()=>{
      function loop(){
          Promise.resolve().then(loop);
      }
      loop();
    });
  </script>
</body>
</html>
```

结果就是当点击按钮后页面渲染会停止浏览器进入到阻塞中, 原因很简单 "微任务队列" 中永远有任务所以浏览器一直在等待 "微任务队列" 清空然后一直执行微任务, 不幸的是这是一个无尽的任务队列所以它永远无法执行完.

微任务的另外一个特性就是 **JavaScript 调用栈一旦被清空, 微任务队列中的任务执行会先于其他队列**, 请观察下面的例子:

```javascript

```



# Node.js 中的事件循环

node.js 的事件循环模型和浏览器不同, 不过在 node11 后进行了统一, 这里我们会分开讨论.

## Node.js 多线程还是多进程?



# 引用

> https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
>
> https://nodejs.org/dist/latest-v12.x/docs/api/worker_threads.html
>
> https://www.dynatrace.com/news/blog/all-you-need-to-know-to-really-understand-the-node-js-event-loop-and-its-metrics/#disqus_thread
>
> https://blog.csdn.net/Fundebug/article/details/86487117
>
> https://www.cnblogs.com/MuYunyun/p/7287413.html
>
> http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html
>
> https://jsbin.com/dijodahawi/edit?html,css,js,console,output
>
> https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
>
> https://segmentfault.com/a/1190000019759283



