# 标题: 事件循环补全计划

# 前言

事件循环(event loop)是一个在 JavaScript 常被提起的概念, 它存在于浏览器也存在于 Node.js 中, 因为它复杂的运行机制和变幻莫测的行为令人难以琢磨, 更是成为面试时候的必考题目.

在本篇文章中将会总结 "事件循环" 这个概念, 无论是浏览器端还是 Node.js 端都会涉及.

为了尽可能的减少错误, 本篇文章的信息来源基于 "官方文档" 以及 "规范" 和 历届 jsconf 大会上的有关 "事件循环" 的演讲, 本篇文章实际上就是把这些内容总结到了一起的结果, 你可以在文章的末尾获取这些内容源地址.



# 浏览器 - 事件循环初探

> https://youtu.be/8aGhZQkoFbQ



我们先从浏览器开始, 因为大部分从事 Node.js 开发的大多数人或多或少都了解浏览器中的事件循环的基本概念.

## JavaScript运行的基本流程

我们都知道JavaScript是一个单线程的编程语言, 这意味着它只能有一个调用栈, 执行过程中每次只能做一件事情.

为了充分理解, 我们来例举一个简单的例子:

```javascript
function fun1() {
  return 'fun1'
}

function fun2() {
  return 'fun2' + fun1();
}

function fun3() {
  console.log(fun2());
}

fun3();
```

一旦代码执行调用栈中函数压入的顺序如下:

```
+----------+ +----------+ +----------+
|    stack | |    stack | |    stack |
|          | |          | |          |
|          | |          | |          |
|          | |          | | +------+ |
|          | |          | | | fun3 | |
|          | |          | | +------+ |
|          | |          | |          |
|          | | +------+ | | +------+ |
|          | | | fun2 | | | | fun2 | |
|          | | +------+ | | +------+ |
|          | |          | |          |
| +------+ | | +------+ | | +------+ |
| | fun1 | | | | fun1 | | | | fun1 | |
| +------+ | | +------+ | | +------+ |
|          | |          | |          |
+----------+ +----------+ +----------+
```

位于栈顶的函数(fun3)执行完成后调用栈会把他弹出:

```
+----------+ +----------+ +----------+
|    stack | |    stack | |    stack |
|          | |          | |          |
|          | |          | |          |
|          | |          | |          |
|   💥     | |          | |          |
|          | |          | |          |
|          | |          | |          |
| +------+ | |          | |          |
| | fun2 | | |    💥    | |          |
| +------+ | |          | |          |
|          | |          | |          |
| +------+ | | +------+ | |          |
| | fun1 | | | | fun1 | | |    ✨    |
| +------+ | | +------+ | |          |
|          | |          | |          |
+----------+ +----------+ +----------+
```

调用栈被JavaScript引擎使用和监视, 所以当我们在函数中抛出了一个错误但是没有对应的 `try/catch` 语句的时候:

```javascript
function fun1() {
  throw new Error('Warning: Nuclear Missile Launched') // 抛出一个错误但是没有对于的 try/catch 语句
}

function fun2() {
  return 'fun2' + fun1();
}

function fun3() {
  console.log(fun2());
}

fun3();
```

可以在控制台中的报错中看到调用栈的信息:

![1566047594418](C:\Users\zhao\Documents\library\article\assets\1566047594418.png)

但是调用栈也是脆弱的如果我们创建一个无法中断调用函数, 那么调用栈会瞬间爆炸💥这种行为被称为 "栈溢出". 可喜可贺的是JavaScript会监视调用栈, 一旦调用栈出现 "栈溢出" JavaScript 会终止代码的执行并且抛出错误:

```javascript
function foobar() {
	foobar();
}

foobar();
```

抛出 "栈溢出" 错误:

![1566048013705](C:\Users\zhao\Documents\library\article\assets\1566048013705.png)

## 阻塞的坏处

在 Web 开发中我们经常要会听到要避免浏览器阻塞, "阻塞" 听起来有点像我们常说的 "电脑卡住了" 中的 "卡住".

实际上阻塞并没有一个严格的定义, JavaScript 的运行速度是很快的, 执行几个简单的 "console.log" 你无法体会到这其中所花费的时间, 如果调用栈中正在执行的函数花费了大量的时间, 我们感觉浏览器被卡住了, 体验不流畅此时我们说, 浏览器被阻塞了.

但是浏览器不仅仅执行 JavaScript 代码还会异步的加载外部资源文件, 这些加载的流程也可以被 JavaScript 所控制, 例如我们通过 JavaScript 发起一个同步的网络请求:

```javascript
var oReq = new XMLHttpRequest();
oReq.onload = function(){};
oReq.open("get", "https://xxx.com/", false); // false 表示同步发送请求(这种方式已经不在被推荐使用仅仅用于示例)
oReq.send();
alert('running!'); // 只有请求完成后 alert 才会执行
```

这个请求有可能需要 20ms 或者 300ms 甚至更长, 在请求的过程中浏览器会一直等待请求完成甚至会停止页面的渲染, 我们可以明显的感受到浏览器卡住了, 这是典型的阻塞.

## 异步回调

浏览器将所有可能花费大量时间等待的操作都提供了对应的异步接口, 这种解决方式被称为 "异步函数" 或者 "回调函数" 或者 "异步回调" 等.

一个典型的例子如下:

```javascript
console.log('hello');

setTimeout(function foobar(){
    console.log('delay');
},1000);

console.log('world');
```

我们都知道这段代码会输出的顺序是:

1. hello
2. world
3. delay

那么浏览器到底是如何解释这段代码的呢, 我们可以观察浏览器的调用栈:

```
console.log('hello'); // 压入栈中执行
console.log('hello'); // 执行完成栈弹出

setTimeout            // 压入栈中执行
setTimeout            // 执行完成栈弹出

console.log('world'); // 压入栈中执行
console.log('world'); // 执行完成栈弹出

-------1000ms过后------

foobar                // 压入栈中执行
console.log('delay'); // 压入栈中执行
console.log('delay'); // 执行完成弹出
foobar                // 执行完成弹出

```

最神奇的事情出现了 `setTimeout` 执行完成后就被调用栈弹出了, 但是不知何故 1000ms 后 `setTimeout` 中的 `foobar` 被神奇的唤醒了, 这是怎么回事?

## 题外话 webapi

在 JavaScript 中执行元素绑定事件, 使用 `setTimeout` 设置一个延时执行, 或者发起一次网络请求. 这些都是web开发者的家常便饭, 对于我们来说这些内容就是 JavaScript 的一部分了, 但是实际上这些内容并没有在 ECMAScript 制定的标准中, 包括我们讨论的 "事件循环" 机制它也没有存在于规范中也就是说这个机制是独立于 JavaScript 引擎的功能.

这些API被称为 `webapi` 它们有自己的规范和实现与 JavaScript 这门语言没有关系, 在这份来自于MDN的[页面上](https://developer.mozilla.org/zh-CN/docs/Web/API)列举了所有的API.

## 基本事件循环

我们之前提到了 JavaScript 由于其单线程的特性只能在同一时间执行同一间事情, 这是正确的, 但是浏览器不仅仅拥有解释 JavaScript 脚本的引擎, 还有一堆其他的程序来处理诸如 `DOM` `XmlHttpRequest` `setTimeout` 这些任务.

这些程序各司其职完成自己负责的部分, 它们是独立于 JavaScript 引擎之外的内容, 这些程序可能运行在独立线程上或者进程上它们通过`webapi` 来和 JavaScript引擎进行通信, 所以我们需要通过 "回调" 的方式进行异步编程.

而 **事件循环** 用于管理这些异步任务在合适的时机执行.

`setTimeout` 作为 `webapi` 典型的例子, 我们来观察一下它是如何运行的, 首先 `setTimeout` 一旦被执行便将函数钩子移交给对应的 `webapi` 并且开始计时:

```
+--------------------------------+     +---------------------+
|                                |     |webapis              |
|                                |     | +----------------+  |
| setTimeout(function foobar() { |     | |                |  |
| 	console.log('delay')         | +-> | | timer-0 -- cb()|  |
| },0);                          |     | |                |  |
|                                |     | +----------------+  |
|                                |     |                     |
+--------------------------------+     +---------------------+
```

由于我们的倒计时是0, 所以计时会立即完成, `webapi` 将函数钩子移交给 **任务队列** .

```
+--------------------------------+     +----------+
|                                |     |webapis   |
|                                |     |          |
| setTimeout(function foobar() { |     |          |
| 	console.log('delay')         |     |          | +-+
| },0);                          |     |          |   |
|                                |     |          |   |
|                                |     |          |   |
+--------------------------------+     +----------+   |
                                                      |
+-------------------------------------------------+   |
|                               task queue        |   |
| +--------------+                                |   |
| |              |                                |   |
| |    cb()      |                                | <-+
| |              |                                |
| +--------------+                                |
|                                                 |
+-------------------------------------------------+

```

接下来终于轮到 **事件循环** 上场了, 事件循环完成一件非常简单的工作, 它判断如果:

1. 调用栈是空的
2. 任务队列中存在着任务

那么就将这个任务移入到调用栈中执行:

```
+--------------------------------+ +------------------+
|                                | |           stack  |
|                                | | +--------------+ |
| setTimeout(function foobar() { | | |              | |
| 	console.log('delay')         | | |  cb - foobar | |
| },0);                          | | |              | |
|                                | | +--------+-----+ |
|                                | |          ^       |
+--------------------------------+ |          |       |
event loop ⏳                      |          |       |
+----+---------------------------+ |          |       |
|    |                           | |          |       |
|    |                           | |          |       |
|    +-- task ------> push -------------------+       |
|                                | |                  |
+--------------------------------+ +------------------+

```

然后往复循环这个过程, 这就是事件循环的基本流程.

现在我们来提出一个 `ajax` 的例子, 尝试一下你能说出他的执行流程吗:

```javascript
console.log('hello');

$.get('https:www.google.com',function foobar(){ console.log('callback') });

console.log('world');
```

他的执行流程如下:

1. console.log('hello') --> 压入调用栈中执行
2. console.log('hello') --> 执行完成弹出调用栈
3. $.get --> 压入栈中执行
4. $.get --> 调用了 `webapi` 中的 `XHR` 发起了网络请求, 并保存其函数钩子
5. $.get --> 执行完成弹出调用栈
6. console.log('world') --> 压入调用栈中执行
7. console.log('world') --> 执行完成弹出调用栈
8. 网络请求完成 `webapi` 将函数钩子移动到任务队列中
9. 事件循环--> 检查调用栈是否为空 检查任务队列中是否有任务 (事件循环一直存在并非在只在此刻进行检查)
   1. 调用栈为空
   2. 检查到请求任务
   3. 将该任务(foobar函数)压入到调用栈中
10. console.log('callback') --> 压入调用栈中执行
11. console.log('callback') --> 执行完成弹出调用栈
12. foobar --> 执行完成弹出调用栈
13. 调用栈再次清空

# 事件循环如何影响渲染

> https://youtu.be/cCOL7MC4Pl0

在上一节中我们提到了 JavaScript 是单线程的如果花费大量的时间运行 JavaScript 那么就会阻塞浏览器, 导致浏览器无法完成其他工作, 并且初次了解了 "事件循环" 是如何解决问题的. 在这一节中我们会更加深入, 探讨 "事件循环" 是如何影响渲染.

实际上事件循环的作用范围可能超乎你的想象, 举个例子所有的DOM事件实际上都是受到了 "事件循环" 控制的, 除此以外还包括包括网络请求, IO操作等等这些常见的功能. 因为在背后这些事件的触发者实际上都是将与事件有关的信息放入到了 "任务队列" 中真正让这些内容被执行的实际上是 "事件循环", 还记得 "事件循环" 是如何工作的吗? 通过以下的两个判断, "事件循环" 会将最近的任务移送到 "调用栈" 中:

1. 任务队列中含有任务
2. 调用栈为空

但是浏览器中不仅仅执行 JavaScript 代码还会处理页面渲染, 我们知道如果进行大量的 JavaScript 计算那么浏览器会停止渲染这里面到底隐藏着何种的基情关系? 我们先来了解一下基本的渲染概念.

## 基本的渲染

我们在页面中动态的修改样式界面会进行实时反应, 所以我们认为这些操作是同步的操作, 但是实际上浏览器在背后进行了优化, 重复多此的样式操作会被进行合并然后由浏览器决定一个合适的时机然后统一更新: 

```javascript
element.style.transition = "transform 1s";
element.style.transform = "translateX(100px)";
element.style.transform = "translateX(500px)";
```

应用了样式的元素并不会横向在 100px 和 500px 之间来回移动而是直接移动到了 500px, 浏览器抛弃了旧的无用的样式修改.

所以说修改样式并不是同步的, 浏览器的优化带来的异步的更新机制导致它和 "事件循环" 之间产生关联, 在了解这些关联前我们先来了解一下浏览器的基本渲染机制.

元素样式决定渲染的结果, 从一堆代码转为可视化的界面经历了许多环节, 这里我们来简单的了解一下其中的几个关键步骤:

1. 计算样式 - 收集 css 计算应用到每个元素上的样式
2. 布局 - 确定页面上的元素的位置层叠关系
3. 绘制 - 创建实际的像素绘制到页面上

## 被动的渲染

在下面的这个例子中使用了一个 `video` 来表示页面进行动态的持续的页面渲染, 这些嵌入的内容可以在不受 JavaScript 的干扰下影响页面的显示, 当点击按钮的时候 JavaScript 进入死循环:

```javascript
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>test</title>
</head>
<body>
  <video src="https://vjs.zencdn.net/v/oceans.mp4" controls autoplay></video>
  <button id="button">while true</button>
  <script>
    document.getElementById('button').addEventListener('click',()=>{
      while(true);
    });
  </script>
</body>
</html>
```

当我们点击了按钮的时候:

1. click 事件被放入到了任务队列中
2. 事件循环将click 事件压入调用栈
3. `while true` 执行

此时渲染工作在等待 JavaScript 执行完成, 但是 JavaScript 进入了无限循环中所以渲染工作就一直在等待中永远不会得到完成.

解释这种行为的一个好的方式就是: **我们不妨把页面的渲染过程也视为 "任务队列" 中的一个任务, 这个任务的创建者就是浏览器本身,它在一个合适的时机把渲染任务放入到任务队列中等待执行, 但是由于代码阻塞导致页面无法及时更新.**

// TODO 有待证实

但是实际的情况要更为复杂一些 "任务队列" 实际上有多个, 渲染是一个复杂的过程它有自己的任务队列, 但是任务队列中的任务执行顺序依然是通过 "事件循环" 来决定的, 所以之前提到的理解方式并没有太大的问题.

## 思考

下列代码会造成阻塞吗:

```javascript
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>test</title>
</head>
<body>
  <video src="https://vjs.zencdn.net/v/oceans.mp4" controls autoplay></video>
  <button id="button">while true</button>
  <script>
    function loop(){
      setTimeout(loop,0);
    }
    loop();
  </script>
</body>
</html>
```

这段代码不仅不会造成阻塞甚至不会造成栈溢出, 每次调用 `loop` 函数会向 "任务队列" 添加一个任务然后 `loop` 就会被弹出调用栈, 此时的调用栈就被清空了. 而负责控制任务队列的事件循环只有在调用栈为空的时候才能继续执行任务, 也就是说调用栈永远不会累加.

其次任务的执行并不影向任务队列添加内容, 在调用 `setTimeout(loop,0)` 后 "事件循环" 继续工作处理那些已经被填入到任务队列中在此之前的填入的其他事件以及页面的渲染, 直到 "任务队列" 中再次执行有关 `loop` 的任务.

## 流畅的渲染

试想一下你在页面上制作了一个动画效果使用如下代码:

```javascript
function animate(){
  // 修改样式
}

setInterval(animate,1000/60);
```

你希望动画可以达到 60fps 所以向 `setInterval` 传入了 `1000/60` 期待它可以每秒执行 60 次动画函数.

但是由于 `setInterval` 并不精确在一帧中可能执行了多此, 也可能一次也没有执行, 或者执行了一个耗时的任务导致浏览器无法在一帧中进行渲染操作.

我们希望每一帧中至少有一次渲染过程, 但是任务的执行是随机的任务执行会打乱原有规律的渲染过程:

![1566277658471](C:\Users\zhao\Documents\library\article\assets\1566277658471.png)

而浏览器本身的渲染实际上是非常智能和节约计算的, 例如页面渲染频率自动和屏幕刷新率调整到一致, 当页面静止或者不可视的时候页面会停止渲染, 而使用 `setInterval` 等很难完美的和页面渲染过程相结合.

一个解决问题的办法就是使用 `requestAnimationFrame`.

> **window.requestAnimationFrame()** 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画

使用 `requestAnimationFrame` 我们可以使用浏览器的渲染逻辑将原本杂乱的渲染过程变得有序起来, 让浏览器决定何时进行渲染, 对于动画渲染这再好不过了, 现在有关动画的任务都被排列到了渲染任务的前面:

![1566279040998](C:\Users\zhao\Documents\library\article\assets\1566279040998.png)

## 微任务 (micro task)

微任务是一个复杂的概念很多人不理解其行为, 我们从微任务的设计目的上来解释微任务的工作原理.

很久前W3C给浏览器制定了一些API, 这些API用于监听DOM的变化:

```javascript
element.addEventListener("DOMNodeInserted", function (ev) {
  // ...
}, false);
```

但是这个API有着严重的性能问题, 只要修改元素的属性对应的事件就会被触发, 对同一个属性修改100次就会触发100次的事件, 另外事件具有冒泡的特性子元素的修改也会导致父元素触发该事件:

```javascript
let i = 100;
while(i--){
  const span = document.createElement('span');
  element.appendChild(span); // 触发事件一次
  span.textContent = 'Test'; // 再次触发事件一次
}
```

结果就是无论你在 `DOMNodeInserted` 回调中写多么简单的代码, 复杂的DOM操作导致事件就会被密集调用大大降低性能, 所以这个API被废弃了.

监听DOM修改的需求依然存在, 但是我们希望这个接口的表现就和渲染一样将DOM修改进行合并后只触发一次, 这个规范在DOM3中被推出他就是 [`MutationObserver`](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver), 从而引入了 "微任务" 和 "微任务队列" 这个概念.

微任务是异步的我们用个 `Promise` 来举例:

```javascript
Promise.resolve().then(()=>console.log('hello world'));
console.log('foobar');
```

输出:

```
foobar
hello world
```

`foobar` 先于 `hello world` 输出这点证明了它. 虽然他是异步的但这不代表他必须遵循 "事件循环" 和 "渲染" 制定的规则. 相反 "微任务" 有自己的玩法.

一个典型的特征就是**只有微任务队列清空后微任务才算执行完成**, 我们把之前的 "事件循环" 例子改为微任务版本:

```javascript
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>test</title>
</head>
<body>
  <video src="https://vjs.zencdn.net/v/oceans.mp4" controls autoplay></video>
  <button id="button">while true</button>
  <script>
    document.getElementById('button').addEventListener('click',()=>{
      function loop(){
          Promise.resolve().then(loop);
      }
      loop();
    });
  </script>
</body>
</html>
```

结果就是当点击按钮后页面渲染会停止浏览器进入到阻塞中, 原因很简单 "微任务队列" 中永远有任务所以浏览器一直在等待 "微任务队列" 清空然后一直执行微任务, 不幸的是这是一个无尽的任务队列所以它永远无法执行完.

微任务的另外一个特性就是 **JavaScript 调用栈一旦被清空, 微任务队列中的任务执行会先于其他队列**, 请观察下面的例子:

```javascript
const button = document.getElementById('button');

button.addEventListener('click',()=>{
	Promise.resolve().then(()=>console.log('Microtask 1'));
	console.log('task 1');
});

button.addEventListener('click',()=>{
	Promise.resolve().then(()=>console.log('Microtask 2'));
	console.log('task 2');
});
```

点击按钮后输出顺序:

```
task 1
Microtask 1
task 2
Microtask 2
```

按钮点击后的执行流程如下:

1. "事件循环" 将第一个点击事件中的匿名函数压入调用栈
   1. 微任务队列中添加任务
   2. 执行 `console.log('task 1')`
   3. 匿名函数执行完成弹出调用栈
   4. 执行微任务队列中的任务
   5. 执行 `console.log('Microtask 1')`
   6. 微任务队列清空
2. "事件循环" 将第二个点击事件中的匿名函数压入调用栈
   1. 微任务队列中添加任务
   2. 执行 `console.log('task 2')`
   3. 匿名函数执行完成弹出调用栈
   4. 执行微任务队列中的任务
   5. 执行 `console.log('Microtask 2')`
   6. 微任务队列清空

不过如果要把这个例子稍稍修改一下情况却略有不同:

```javascript
const button = document.createElement('button');

button.addEventListener('click',()=>{
	Promise.resolve().then(()=>console.log('Microtask 1'));
	console.log('task 1');
});

button.addEventListener('click',()=>{
	Promise.resolve().then(()=>console.log('Microtask 2'));
	console.log('task 2');
});

button.click();
```

这次我们手动触发 `click` 事件, 输出结果如下:

```
task 1
task 2
Microtask 1
Microtask 2
```

这次的执行流程为:

1. `button.click()` 被压入调用栈执行
2. 同步触发 'click' 事件并将第一个事件回调压入调用栈
   1. 微任务队列中添加任务 `console.log('Microtask 1')`
   2. 执行 `console.log('task 1')`
   3. 匿名函数执行完成弹出调用栈
- **注意**: 此时 `button.click` 并未执行完成还在调用栈中
3. 同步触发 'click' 事件并将第二个事件回调压入调用栈
   1. 微任务队列中添加任务 `console.log('Microtask 2')`
   2. 执行 `console.log('task 2')`
   3. 匿名函数执行完成弹出调用栈
4. `button.click` 从调用栈中弹出
5. 清空微任务队列
6. 执行 `console.log('Microtask 1')`
7. 执行 `console.log('Microtask 2')`
8. 微任务队列清空

# Node.js 中的事件循环

> https://youtu.be/zphcsoSJMvM

## 计算机线程进化史

回到 `ms-dos` 和 `Apple os` 的时代那时候的操作系统使用命令行界面, 计算机CPU只有一个核心, 操作系统同一时间下只能执行一件事情.通过操作界面告诉操作系统你要运行一个应用程序, 此时系统会停止运行并运行那个程序, 当应用程序执行完后又把执行权力交由操作系统.

这种设计有着非常大的限制, 你无法同时执行多件事情, 于是一种被称作协作多任务(cooperative multitasking)的机制出现了. 这种设计下你可以同时运行多个程序.

但是这种机制出现后表现各大操作系统的实现也不是十分完美, 在当时的 `Mac OS` 和 `windows` 操作系统中这种多程序执行的实现交由应用程序决定, 如果程序没有编写对应的代码那么这个程序会一直占用CPU资源, 如果一旦程序崩溃甚至会牵扯到系统, 导致系统崩溃.

后来这种机制被改为了抢占式多任务(preemptive multitasking), 运行哪个程序由操作系统决定, 在切换应用程序的时候他会把正在运行中的程序暂停然后保留其状态存储到其他位置中, 然后加载另外一个程序. 这项机制最初引用到了面向服务器的 Unix 系统, 在随后的时间里才应用到了使用 NT 内核的 windows2000 和同时期的 Mac OS 1004 的个人电脑中.

此时AMD刚刚发布了它的多核CPU, 为了充分利用多核CPU的性能, 均衡多线程(symmetric multi threading)技术诞生了, 该技术的实际应用被 intel 首先采用并重新命名为超线程(hyper threading). 该技术的主要原理是: CPU在执行任务的时候并非一直满载执行, 这里有很多空闲资源可以利用, 而超线程允许一个CPU核心可以同时处理多件事情充分的利用CPU空闲资源.

在上文中我们提到了两个基本的概念 "任务" 和 "线程", 实际上任务就是我们常说的 "进程", 线程和进程的概念我们就在这里不提了, 我们需要提到的一点就是线程的 "竞态". 线程的执行是并行的线程间共享内容, 当两个线程操作同一个数据的时候会出现这种问题.

假设我们有两个线程线程A向全局变量写入一个数据,线程B读取对应的全局变量,由于两个线程都是并行的所以线程A可能在线程B读取前进行了写入, 也有可能线程B先读取后线程A再写入, 每次运行都会得到不同的结果. 这让程序充满了不确定性也会导致很多bug, 许多语言都提供了线程安全的操作来避免问题不过即使是经验丰富的程序员往往也得仔细思考才能设计出线程安全的程序.

**对于Node来说解决的方式非常简单直接, 我们使用单线程模型, 不允许你使用多线程模型(Node 11中添加了实验中的多线程支持).**

## Event loop

Node.js 的官方网站上有一篇解释 Event loop 的[文章](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#the-node-js-event-loop-timers-and-process-nexttick), 本来打算借用其他人的翻译的不过没有一篇是原汁原味的版本, 只好自己动手了.

### 什么是事件循环

事件循环允许node.js执行非阻塞I/O操作. 虽然 JavaScript 是单线程的, 但是事件循环会尽可能的将操作转移到系统内核中来完成.

现代的操作系统内核都是多线程的, 它们可以在后台处理多种操作. 一旦这些操作完成, 系统内核会通知 Node.js 以便将事件回调放入轮询队列中等待执行. (我们会在随后的内容讨论它们的具体工作细节)

### 解析事件循环

当 Node.js 启动的时候, 他会初始化事件循环, 处理输入的脚本内容 (或者进入 [REPL](https://nodejs.org/api/repl.html#repl_repl)), 脚本可能会调用异步接口, 设置定时器, 或者调用 `process.nextTick()`, 然后开始处理事件循环.

下面的简图中展示了事件循环的操作流程:

```
   ┌───────────────────────┐
┌─>│        timers 计时器   │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll 轮询      │<─────┤  connections, │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check 检查      │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
```

> 每一个方框代表了事件循环中不同的阶段(事件循环会重复执行这些步骤).

每一个阶段都有 FIFO 队列用于执行. 虽然不同的队列执行方式不同, 总的来看, 当事件循环进入该阶段后会执行该阶段的所有的操作, 然后调用对应的回调直到队列耗尽或者达到了回调执行上限. 在到达上述情况后事件循环进入下一阶段, 然后继续这样的流程.

由于单个操作的执行可能会产生额外的操作以及在轮询阶段产生的新事件会被内核排队, 这些新的操作会在处理轮询事件的时候排队. 因此, 执行一个长耗时的回调可以在轮询阶段超出定时器的阈值.

> *Windows and the Unix/Linux* 平台略有差别, 但是这不影响我们的讨论. 我们最关心的是 Node.js 实际执行的那部分也就是上面的内容.

### 阶段总览

- timer: 此阶段执行由 `setTimeout()` 和 `setInterval()` 设定的回调.
- pending callbacks: 执行被推迟到下一轮循环的 I/O 回调.
- idle, prepare: 仅内部使用.
- poll: 获取新的I/O事件; 执行 I/O 回调(除了 close 回调以及 timer 回调和 `setImmediate` 回调都会在这里执行), node会在适当条件下在这里阻塞.
- check: `setImmediate` 回调将会在次执行.
- close callbacks: 一些执行关闭的函数, 例如 `socket.on('close', ...)`.

Node 会在两次事件循环间检查是否存在 I/O 操作和或者 timer, 如果没有就会退出执行.

### 各阶段中的细节

#### timer

timer 指定了运行回调的阈值时间, 而不是人们所想的执行时间. 定时器回调将会在指定的时间到达后尽快的执行, 不过 timer 的执行会受到操作系统调度和其他回调执行的影响被延后.

> 从技术上讲, 决定是否执行 timer 回调是在轮询阶段控制的, 在 timer 阶段才会执行这些回调.

举例来说, 你制定了一个延时 100ms 的 timer, 然后异步进行读取文件花费了 95ms:

```javascript
const fs = require('fs');

function someAsyncOperation(callback) {
  // Assume this takes 95ms to complete
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() => {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);


// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() => {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback < 10) {
    // do nothing
  }
});
```

当事件循环进入轮询队列后, 此时队列是空的(`fs.readFile()` 还未完成), 现在我们等待计时器到达指定的阈值. 过了 95ms 后 `fs.readFile` 读取完毕并且执行回调共花费 10ms. 当回调执行完成, 轮询队列中没有任何内容了, 此时事件循环会看到已经到达阈值的 timer, 然后在 timer阶段去执行回调. 所以在这个例子中的延时函数会在 105ms 后执行.

> 为了防止事件循环被长时间空置,  [libuv](https://libuv.org/) 有一个最大限值(取决于操作系统)用于限制轮询队列的执行次数.

#### pending callbacks

系统操作例如: TCP类型错误执行回调会安排在这个阶段执行. 例如当尝试 TCP 连接的时候接收到了一个 `ECONNREFUSED` 错误, 有些 *nix 系统会进行等待而不是立即抛出错误. 这些回调会被添加到队列中在 `pending callbacks` 阶段执行.

#### poll

在这个阶段中主要完成两个功能:

1. 计算被阻塞和轮询 I/O 花费的时间, 然后
2. 处理轮询队列中的事件

当事件轮询到了 poll 阶段的时候发现没有计时器到达阈值, 此时会发生两种情况:

1. 如果轮询队列中有内容, 事件循环会遍历轮询队列然后逐个执行内部的回调, 直到队列清空或接近轮询阶段的回调执行上限(上限取决于操作系统).
2. 如果轮询队列为空, 此时
   - 如果存在 `setImmediate()` 任务, 事件循环会结束轮询阶段直接跳入 check 阶段去执行那些 `setImmediate()` 任务.
   - 如果没有需要处理的 `setImmediate()` 任务, 事件循环会在轮询阶段等待新的任务被添加到轮询队列中, 然后立即处理这些添加进来的任务.

轮询队列为空后, 事件循环将检查已达到时间阈值的计时器. 如果一个或者多个计时器到达阈值, 事件循环会移动到 timer 阶段然后执行那些计时器回调.

#### check

这个阶段允许在轮询后立即执行回调. 如果轮询阶段进入等待, 并且有被 `setImmediate()` 设定的回调, 那么事件循环有可能会移动到 check 阶段而不是继续在轮询阶段等待.

`setImmediate()` 实际上是一个特殊的计时器, 在事件循环的一个单独阶段中执行. 在轮询阶段后执行的 check 阶段回调的执行是通过 `libuv` 接口运行的.

## 不是单线程的 Node

JavaScript 是单线程的这没有问题, 因为在 Node 中所有的 "JavaScript 脚本", "V8 引擎", "事件循环", 都运行在一个线程中这个线程被称为 "主线程".

**但是这不意味着 Node 本身是单线程的因为 Node 还有其他部分**. Node 的源码中还包括了 C++ 代码, C++部分拥有操作线程的能力, 这取决于你调用 JavaScript API的方式. 例如如果你调用了一个 Node 的 API, 这个 API 背后是由 C++ 代码提供支持的. 如果你同步的调用那么 C++ 代码会在主线程上执行. 如果你调用一个异步的 Node 接口, 那么 C++ 有可能会使用额外的线程来执行这个任务.

所以使用同步 API 那么 Node 就没有机会利用多线程的并行计算的特性来提升性能, 所以在任何时候都推荐使用异步的接口, 这样可以利用 Node 内部的线程机制进行优化执行效率.

在默认情况下 Node 会使用线程池线程池的容量为 4 (可以通过环境变量进行修改), 当需要线程的任务超过4个后, Node 会将任务放入到任务队列中. 一旦空闲线程出现 Node 会将任务从队列中取出放入到线程中执行.

**图片:**使用命令行启动的 Node 就使用了12个线程:

![1566385151734](C:\Users\zhao\Documents\library\article\assets\1566385151734.png)

还有一些异步任务不利用线程池, 例如 `http.request` 背后 C++ 会尽可能的调用异步接口来将任务委托给操作系统, 利用系统提供的接口 epoll(linux) kqueue(mac os), GetQueuedCompletionStatusEx(Windows).

下列的列表中例举了异步 API 背后的运行机制:

- Kernal Async
  - TCP/UDP servers and clients
  - pipes
  - dns.resolveXXX
- *NIX Only
  - UNIX domain sockets
  - TTY input
  - *NIX signals
  - Child Process
- Thread Pool
  - fs.*
  - dns.lookup
  - pipes(edge case)
- Windows Only
  - Child Process
  - TTY Input
  - TCP servers(edge cases)

在线程的

## 单线程的 Event Loop

很多人认为 Event loop 是独立的它运行在一个单独的线程中, 但是实际上 Event Loop 作为 JavaScript 部分的内容是和 JavaScript 一样运行在主线程上的.





# 引用

> https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/
>
> https://nodejs.org/dist/latest-v12.x/docs/api/worker_threads.html
>
> https://www.dynatrace.com/news/blog/all-you-need-to-know-to-really-understand-the-node-js-event-loop-and-its-metrics/#disqus_thread
>
> https://blog.csdn.net/Fundebug/article/details/86487117
>
> https://www.cnblogs.com/MuYunyun/p/7287413.html
>
> http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html
>
> https://jsbin.com/dijodahawi/edit?html,css,js,console,output
>
> https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
>
> https://segmentfault.com/a/1190000019759283



