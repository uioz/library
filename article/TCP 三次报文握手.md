# TCP 三次报文握手

## TCP 连接建立

存在客户端 A 和服务器 B. 此时 A 发起连接建立:

1. A 的 TCP 客户端进程创建**传输控制模块** TCB.
2. 向 B 发送连接请求报文段, 此报文包含
   1. 首部同步位 SYN = 1
      1. 规定 SYN 报文段不能携带数据
      2. 规定需要消耗掉一个序号
   2. 初始序列号码 seq = x
   3. ACK = 0
3. 此时 TCP 进程进入 SYN-SENT(同步已发送)状态.

当 B 接收到**连接请求报文段**后, 如果同意连接, 则向 A 发送确认. 在确认报文中:

- SYN = 1
- ACK = 1
- 确认号 ack = x + 1
- 初始序列号 seq = y
- 报文段不能携带数据
- 要消耗掉一个序号

此时 TCP 服务器进程进入到 SYN-RCVD(同步收到)的状态.

TCP 客户端 A 接收到 TCP 服务器 B 的确认后, 还要向 B 给出确认. 确认报文段:

- ACK = 1
- 确认号 ack = y + 1
- 序号 seq = x + 1
- ACK 报文段可以携带数据
  - 不携带数据则不消耗序号, 则下一次的数据报文段序号仍是 seq = x + 1

此时 TCP 连接已经建立, A 进入 ESTABLISHED(已建立连接)状态.

### 为什么 A 需要发送确认报文

1. A 发送连接请求报文
   1. 报文请求失败(网络延时未响应)再次执行 1
2. 连接建立

我们假设 A 执行了两次步骤 1 因为第一次网络延时未响应. 而第二次发送的报文建立的连接. 这个连接在收发完数据后就关闭了.

但是 A 认为无效的连接报文, 结果在连接完成后到了 B 手中, B 认为 A 又发起了连接(即使这是 A 发送的第一个连接报文), B 便响应 A 同意连接建立.

如果没有 A 的再次确认这种设计, 那么 B 便会认为 B 和 A 已经建立了连接, 但实际上并没有因为 A 并不这样认为. B 维护 TCP 连接会有额外的开销而这个连接将永远不会被取消.

因为存在 A 的确认, 所以 B 同意建立连接的报文发送到 A 的时候, A 会忽略它, 而 B 在长时间未收到确认后便会自动终止这个连接.

## 总结

实际上在握手的三次报文交互中:

1. A -> B
2. B -> A
3. A -> B

一共发送了两种报文:

1. 同步报文段, 即 SYN = 1, seq = x
2. 确认报文段, 即 ACK = 1, ack = x + 1

在第一次交互中, 发送的是同步报文段.

在第二次交互中, 发送的是同步报文段和确认报文段. 而在这个步骤中两个报文是可以拆开发送的所以可以看作是两种不同的功能.

在第三次交互中, 发送的是确认报文段, 和序号, 这里不需要同步位了因为已经完成同步.

而确认报文段所增加的序号实际上就是随着确认报文段一同而来的序号.

# TCP 连接关闭

TCP 连接建立成功连接双方 A 和 B 都处于 ESTABLISHED 状态. 双方都可以发起连接关闭的报文. 所以期待关闭连接的是 A 而 B 则是被动接收连接关闭的一方.

当 A 发送连接释放报文如下:

1. 终止控制位 FIN = 1
2. seq = u (u指的是前面已传送过的字节+1)

发送完成后 A 进入 FIN-WAIT-1 (终止等待1) 状态, 等待 B 确认. **TCP 规定, FIN 报文段即使不携带数据, 它也得消耗掉一个序号.**

B 收到连接释放报文段后即发出确认, 确认号 ack = u + 1. B 进入 CLOSE-WAIT (关闭等待) 状态. 此时 A -> B 方向断开, TCP 处于半关闭 (half-close) 状态, 即 A 已经没有数据要发送了, 但如果 B 发送数据 A 必须要接收.

而 A 收到 B 的确认报文后, 进入 FIN-WAIT-2 (终止等待 2) 状态, 等待 B 发出的连接释放报文段.

如果 B 已经没有要向 A 发送的数据了. 此时 B 发送连接释放报文:

	- FIN = 1

此时 B 就进入了 LAST-ACK (最后确认) 状态, 等待 A 的确认.

A 在收到 B 的连接释放后, 必须对此发出确认. 在确认报文中把:

- ACK = 1
- 确认号 ack = w + 1

进入到 TIME-WAIT 状态.

此时会等待 2 分钟后进入 CLOSED 状态, 之所以需要等待一段时间是要保证:

1. 确保A 对 B 的确认发送到了 B 的手中
   1. 如果 B 未收到就无法释放资源
2. 确保 "A 对 B 的确认" 这段报文已经从网络中消失
   1. 否则 A 与 B 再次建立连接后, B 会收到 A 的这段旧报文

TCP 还有一个**保活计时器**的设计, 作为服务端长时间接受不到客户端的消息(一般时两个)小时, 则服务器会根据如下规则发送探测报文:

- 每隔 75 秒发送一个探测报文
  - 如果连续 10 个没有响应
  - 则关闭连接

## 总结

连接关闭的过程分为四个步骤:

1. A -> B
2. B -> A
3. B -> A
4. A -> B

在连接关闭的过程中报文被分为以下几种类型:

1. 连接释放报文段 FIN = 1 , seq=x
2. 确认报文段 ACK = 1 , seq = x , ack = x+1

第一个环节中 A 向 B 发起连接释放报文段.

第二个环节 B 向 A 确认, 表示收到 A 发起的连接释放.

- 此时 A 保证不会继续向 B 发送数据了
- 但是此时 B 依然可以向 A 发送数据

第三个环节 B 向 A 发送连接释放报文段.

第四个环节 A 向 B 发送确认, 表示 A 收到了 B 的连接释放.

**注意**: 在确认报文的时候 ack = x + 1 的 x 实际上就是对方在连接释放时候所提供的序号.

**注意**: 当提供连接释放请求时候即 FIN = 1 所提供的 seq 都是当前以发送的子节 + 1.

**注意**: 上述规则实际上和连接建立的规则本质是一样的.