# TCP 三次报文握手

## TCP 连接建立

存在客户端 A 和服务器 B. 此时 A 发起连接建立:

1. A 的 TCP 客户端进程创建**传输控制模块** TCB.
2. 向 B 发送连接请求报文段, 此报文包含
   1. 首部同步位 SYN = 1
      1. 规定 SYN 报文段不能携带数据
      2. 规定需要消耗掉一个序号
   2. 初始序列号码 seq = x
   3. ACK = 0
3. 此时 TCP 进程进入 SYN-SENT(同步已发送)状态.

当 B 接收到**连接请求报文段**后, 如果同意连接, 则向 A 发送确认. 在确认报文中:

- SYN = 1
- ACK = 1
- 确认号 ack = x + 1
- 初始序列号 seq = y
- 报文段不能携带数据
- 要消耗掉一个序号

此时 TCP 服务器进程进入到 SYN-RCVD(同步收到)的状态.

TCP 客户端 A 接收到 TCP 服务器 B 的确认后, 还要向 B 给出确认. 确认报文段:

- ACK = 1
- 确认号 ack = y + 1
- 序号 seq = x + 1
- ACK 报文段可以携带数据
  - 不携带数据则不消耗序号, 则下一次的数据报文段序号仍是 seq = x + 1

此时 TCP 连接已经建立, A 进入 ESTABLISHED(已建立连接)状态.

### 为什么 A 需要发送确认报文

1. A 发送连接请求报文
   1. 报文请求失败(网络延时未响应)再次执行 1
2. 连接建立

我们假设 A 执行了两次步骤 1 因为第一次网络延时未响应. 而第二次发送的报文建立的连接. 这个连接在收发完数据后就关闭了.

但是 A 认为无效的连接报文, 结果在连接完成后到了 B 手中, B 认为 A 又发起了连接(即使这是 A 发送的第一个连接报文), B 便响应 A 同意连接建立.

如果没有 A 的再次确认这种设计, 那么 B 便会认为 B 和 A 已经建立了连接, 但实际上并没有因为 A 并不这样认为. B 维护 TCP 连接会有额外的开销而这个连接将永远不会被取消.

因为存在 A 的确认, 所以 B 同意建立连接的报文发送到 A 的时候, A 会忽略它, 而 B 在长时间未收到确认后便会自动终止这个连接.

## TCP 连接关闭

TCP 连接建立成功连接双方 A 和 B 都处于 ESTABLISHED 状态. 双方都可以发起连接关闭的报文. 所以期待关闭连接的是 A 而 B 则是被动接收连接关闭的一方.

当 A 发送连接释放报文如下:

1. 终止控制位 FIN = 1
2. seq = u (u指的是前面已传送过的字节+1)

发送完成后 A 进入 FIN-WAIT-1 (终止等待1) 状态, 等待 B 确认. **TCP 规定, FIN 报文段即使不携带数据, 它也得消耗掉一个序号.

B 收到连接释放报文段后即发出确认, 确认号 ack = u + 1. B 进入 CLOSE-WAIT (关闭等待) 状态. 此时 A -> B 方向断开, TCP 处于半关闭 (half-close) 状态, 即 A 已经没有数据要发送了, 但如果 B 发送数据 A 必须要接收.

而 A 收到 B 的确认报文后, 进入 FIN-WAIT-2 (终止等待 2) 状态, 等待 B 发出的连接释放报文段.

如果 B 已经没有要向 A 发送的数据了. 此时 B 发送连接释放报文:

	- FIN = 1

此时 B 就进入了 LAST-ACK (最后确认) 状态, 等待 A 的确认.

A 在收到 B 的连接释放后, 必须对此发出确认. 在确认报文中把:

- ACK = 1
- 确认号 ack = w + 1

进入到 TIME-WAIT 状态.

此时会等待 2 分钟后进入 CLOSED 状态, 之所以需要等待一段时间是要保证:

1. 确保A 对 B 的确认发送到了 B 的手中
   1. 如果 B 未收到就无法释放资源
2. 确保 "A 对 B 的确认" 这段报文已经从网络中消失
   1. 否则 A 与 B 再次建立连接后, B 会收到 A 的这段旧报文

另外 TCP 还有一个 保活计时器(keepalive timer). 确保连接的两端不会因为故障而导致资源无法释放.

服务器没收到客户端的数据一次就会重置计时器一次, 时间的设置通常是 2 小时, 如果两小时没有收到客户的数据:

- 每隔 75 秒发送一个探测报文
  - 连续 10 个没有响应
    - 关闭连接

