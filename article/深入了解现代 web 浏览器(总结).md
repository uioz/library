# 说明

为了节省时间便不在一一翻译, 机翻问题不大的话就直接 copy 机翻了.

原文地址:

> https://developers.google.com/web/updates/2018/09/inside-browser-part1

# 不同的进程都在控制什么

| 进程   |                                                              |
| ------ | ------------------------------------------------------------ |
| 浏览器 | 控制应用程序的“ chrome”部分，包括地址栏，书签，后退和前进按钮。还处理Web浏览器的隐形，特权部分，例如网络请求和文件访问。 |
| 渲染区 | 控制显示网站的标签内的所有内容。                             |
| 插件   | 控制网站使用的所有插件，例如Flash。                          |
| GPU    | 与其他进程隔离地处理GPU任务。由于GPU处理来自多个应用程序的请求并将它们绘制在同一表面上，因此将其分为不同的过程。 |

## 标签页多进程架构

在最简单的情况下，您可以想象每个选项卡都有其自己的渲染器过程。假设您有3个标签页打开，并且每个标签页都是由独立的渲染器进程运行的。如果一个选项卡变得无响应，则可以关闭无响应的选项卡并继续运行，同时保持其他选项卡的活动状态。如果所有选项卡都在一个进程上运行，则当一个选项卡无响应时，所有选项卡将无响应。真伤心

将浏览器的工作分为多个过程的另一个好处是安全性和沙箱处理。由于操作系统提供了一种限制进程特权的方法，因此浏览器可以从某些功能中沙漏某些进程。例如，Chrome浏览器限制了处理诸如渲染器进程之类的任意用户输入的进程的任意文件访问。

由于进程具有自己的私有内存空间，因此它们通常包含通用基础结构的副本（例如V8，这是Chrome的JavaScript引擎）。这意味着更多的内存使用情况，因为如果它们是同一进程中的线程，将无法共享它们。为了节省内存，Chrome对可启动的进程数量进行了限制。该限制取决于设备拥有的内存和CPU能力，但是当Chrome浏览器达到该限制时，它将在一个过程中开始从同一站点运行多个选项卡。

## iframe 渲染进程隔离

[网站隔离](https://developers.google.com/web/updates/2018/07/site-isolation)是Chrome最近引入的功能，可为每个跨网站iframe运行单独的渲染器进程。我们一直在讨论每个选项卡模型一个渲染器进程，该进程允许跨站点iframe在单个渲染器进程中运行，并在不同站点之间共享内存空间。在相同的渲染器进程中运行a.com和b.com似乎可以。“ [相同来源策略”](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) 是Web的核心安全模型。这样可以确保一个站点未经同意就无法访问其他站点的数据。绕过此策略是安全攻击的主要目标。进程隔离是分离站点的最有效方法。随着 [融化和幽灵](https://developers.google.com/web/updates/2018/02/meltdown-spectre)，显然我们需要使用流程来分隔站点。从Chrome 67开始，默认情况下在桌面上启用“网站隔离”，因此标签中的每个跨网站iframe都会获得一个单独的渲染器进程。

# 浏览器进程

| 线程名称 |                                      |
| -------- | ------------------------------------ |
| UI线程   | 绘制浏览器按钮地址栏等               |
| 网络线程 | 用于处理网络堆栈以从Internet接收数据 |
| 存储线程 | 用户控制对文件的访问                 |

在地址栏中键入URL时，输入将由浏览器进程的UI线程处理。

## 简单导航

### 步骤1 处理输入

当用户开始在地址栏中输入内容时，UI线程首先问的是“这是搜索查询还是URL？”。在Chrome浏览器中，地址栏也是搜索输入字段，因此UI线程需要解析并决定是将您发送到搜索引擎还是请求的网站。

### 步骤2 开始浏览

当用户按下Enter键时，UI线程将发起网络调用以获取网站内容。加载微调框将显示在选项卡的角上，并且网络线程会通过适当的协议（例如DNS查找和为请求建立TLS连接）进行操作。

此时，网络线程可能会收到服务器重定向标头，如HTTP301。在这种情况下，网络线程与服务器正在请求重定向的UI线程进行通信。然后，将启动另一个URL请求。

### 步骤3 读取回应

一旦响应主体（有效负载）开始进入，网络线程将在必要时查看流的前几个字节。响应的Content-Type标头应说明数据的类型，但是由于可能丢失或错误， 因此在此处进行[MIME Type嗅探](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)。如[源代码](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5)中[所述，](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5)这是一件“小事” 。您可以阅读评论，以了解不同的浏览器如何处理内容类型/有效负载对。

如果响应是HTML文件，则下一步是将数据传递到渲染器进程，但是如果它是zip文件或其他文件，则意味着这是一个下载请求，因此他们需要将数据传递到下载管理器。

这也是在那里[安全浏览](https://safebrowsing.google.com/)检查情况。如果域和响应数据似乎与已知的恶意站点匹配，则网络线程将发出警报以显示警告页面。Additionally, [**C**ross **O**rigin **R**ead **B**locking (**CORB**)](https://www.chromium.org/Home/chromium-security/corb-for-developers) check happens in order to make sure sensitive cross-site data does not make it to the renderer process.

### 步骤3 查找渲染器进程

一旦完成所有检查，并且Network线程确信浏览器应导航到请求的站点，则Network线程将告知UI线程数据已准备就绪。然后，UI线程找到一个渲染器进程来进行网页渲染。

网络请求存在延迟, 在步骤2执行的同时, UI线程尝试寻找渲染器进程. 这样当网络线程接收到数据的时候, 渲染器进程已经处于待机位置.

### 步骤4 提交导航

将准备号的数据和渲染器进程, 利用 IPC 将导航数据从浏览器进程传送到渲染器进程中. 这个过程是持续的, 渲染器进程可以持续接收 HTML 数据. 一旦浏览器进程监听到渲染器进程接收到数据的信号, 导航则视为完成, 文档加载阶段开始.

- 地址栏更新
- 安全指示符和站点设置UI反映了新页面的站点信息
- 标签的会话历史记录将被更新
- 因此后退/前进按钮将逐步浏览刚刚导航到的站点
- 会话历史记录存储在磁盘上

### 额外步骤 初始加载完成

提交导航后, 渲染器进程将持续加载资源并且渲染页面. 当渲染器进程 "完成" 渲染后, 他将 IPC 送回浏览器进程(在 onload 时间彻底执行完成后), UI 线程会停止标签页面上加载指示器的显示(就是那个小圆圈).

# 渲染器进程

渲染器进程负责渲染卡内部所有的事情. 渲染器进程中, 主线程处理绝大数用户接收到的代码. 如果使用 network worker 或者 service worker, 则有时部分工作交由 worker(线程) 处理. 合成器和光栅线程也在渲染进程内部.

渲染器进程的核心工作是将HTML，CSS和JavaScript转换为用户可以与之交互的网页。

## 解析

当渲染进程接收到了用于导航的提交消息且开始接收 HTML 数据. 主线程开始解析这些文本将其转为 DOM.

### 子资源加载

网站中引用的外部资源:

- image
- css
- javascript
- ...

这些文件会从缓存或者网络中加载. 主线程可以在解析 HTML 的时候一个一个的加载, 但是为了加快速度, "preload scanner"会同时执行. 如果有类似 `<img>` 或者 `<link>` 在 DOM 中, "preload scanner" 会拿上解析后的标记然后向浏览器进程的网络线程发起请求.

### JavaScript 会阻塞解析

如果 HTML 解析器发现 `<script>` 标签, 会停止解析等待脚本加载完成后继续解析. 因为脚本可能更改 DOM 结构, 导致

### 告诉浏览器你想要的加载姿势

对于 script 可以使用:

- async
- defer
- module

属性来让浏览器异步加载.

对于 link 可以使用:

- preload
- prefetch

来让资源优先加载.

## 样式计算

主线程会解析样式通过 CSS, 为每一个 DOM 上的节点添加计算后的样式. 这些信息用于描述基于 CSS 选择器 DOM 节点应用了哪些样式. 可以通过浏览器开发者工具的 computed 选项卡查看.

## 布局

只有样式和DOM还不足以渲染出页面.

布局是查找元素几何形状的过程。主线程遍历DOM和计算样式，并创建布局树，该树具有诸如 x y 坐标和边界框大小之类的信息。布局树的结构可能与DOM树类似，但它仅包含与页面上可见内容有关的信息。如果`display: none`应用，则该元素不属于布局树（但是，具有的元素`visibility: hidden`在布局树中）。类似地，如果应用了具有类似内容的伪类，`p::before{content:"Hi!"}`即使它不在DOM中，它也将包含在布局树中。

> https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browsers_we_will_talk_about