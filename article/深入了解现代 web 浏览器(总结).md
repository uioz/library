# 说明

为了节省时间便不在一一翻译, 机翻问题不大的话就直接 copy 机翻了.

原文地址:

> https://developers.google.com/web/updates/2018/09/inside-browser-part1

# 不同的进程都在控制什么

| 进程   |                                                              |
| ------ | ------------------------------------------------------------ |
| 浏览器 | 控制应用程序的“ chrome”部分，包括地址栏，书签，后退和前进按钮。还处理Web浏览器的隐形，特权部分，例如网络请求和文件访问。 |
| 渲染区 | 控制显示网站的标签内的所有内容。                             |
| 插件   | 控制网站使用的所有插件，例如Flash。                          |
| GPU    | 与其他进程隔离地处理GPU任务。由于GPU处理来自多个应用程序的请求并将它们绘制在同一表面上，因此将其分为不同的过程。 |

## 标签页多进程架构

在最简单的情况下，您可以想象每个选项卡都有其自己的渲染器过程。假设您有3个标签页打开，并且每个标签页都是由独立的渲染器进程运行的。如果一个选项卡变得无响应，则可以关闭无响应的选项卡并继续运行，同时保持其他选项卡的活动状态。如果所有选项卡都在一个进程上运行，则当一个选项卡无响应时，所有选项卡将无响应。真伤心

将浏览器的工作分为多个过程的另一个好处是安全性和沙箱处理。由于操作系统提供了一种限制进程特权的方法，因此浏览器可以从某些功能中沙漏某些进程。例如，Chrome浏览器限制了处理诸如渲染器进程之类的任意用户输入的进程的任意文件访问。

由于进程具有自己的私有内存空间，因此它们通常包含通用基础结构的副本（例如V8，这是Chrome的JavaScript引擎）。这意味着更多的内存使用情况，因为如果它们是同一进程中的线程，将无法共享它们。为了节省内存，Chrome对可启动的进程数量进行了限制。该限制取决于设备拥有的内存和CPU能力，但是当Chrome浏览器达到该限制时，它将在一个过程中开始从同一站点运行多个选项卡。

## iframe 渲染进程隔离

[网站隔离](https://developers.google.com/web/updates/2018/07/site-isolation)是Chrome最近引入的功能，可为每个跨网站iframe运行单独的渲染器进程。我们一直在讨论每个选项卡模型一个渲染器进程，该进程允许跨站点iframe在单个渲染器进程中运行，并在不同站点之间共享内存空间。在相同的渲染器进程中运行a.com和b.com似乎可以。“ [相同来源策略”](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy) 是Web的核心安全模型。这样可以确保一个站点未经同意就无法访问其他站点的数据。绕过此策略是安全攻击的主要目标。进程隔离是分离站点的最有效方法。随着 [融化和幽灵](https://developers.google.com/web/updates/2018/02/meltdown-spectre)，显然我们需要使用流程来分隔站点。从Chrome 67开始，默认情况下在桌面上启用“网站隔离”，因此标签中的每个跨网站iframe都会获得一个单独的渲染器进程。

# 浏览器进程

| 线程名称 |                                      |
| -------- | ------------------------------------ |
| UI线程   | 绘制浏览器按钮地址栏等               |
| 网络线程 | 用于处理网络堆栈以从Internet接收数据 |
| 存储线程 | 用户控制对文件的访问                 |

在地址栏中键入URL时，输入将由浏览器进程的UI线程处理。

## 简单导航

### 步骤1 处理输入

当用户开始在地址栏中输入内容时，UI线程首先问的是“这是搜索查询还是URL？”。在Chrome浏览器中，地址栏也是搜索输入字段，因此UI线程需要解析并决定是将您发送到搜索引擎还是请求的网站。

### 步骤2 开始浏览

当用户按下Enter键时，UI线程将发起网络调用以获取网站内容。加载微调框将显示在选项卡的角上，并且网络线程会通过适当的协议（例如DNS查找和为请求建立TLS连接）进行操作。

此时，网络线程可能会收到服务器重定向标头，如HTTP301。在这种情况下，网络线程与服务器正在请求重定向的UI线程进行通信。然后，将启动另一个URL请求。

### 步骤3 读取回应

一旦响应主体（有效负载）开始进入，网络线程将在必要时查看流的前几个字节。响应的Content-Type标头应说明数据的类型，但是由于可能丢失或错误， 因此在此处进行[MIME Type嗅探](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)。如[源代码](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5)中[所述，](https://cs.chromium.org/chromium/src/net/base/mime_sniffer.cc?sq=package:chromium&dr=CS&l=5)这是一件“小事” 。您可以阅读评论，以了解不同的浏览器如何处理内容类型/有效负载对。

如果响应是HTML文件，则下一步是将数据传递到渲染器进程，但是如果它是zip文件或其他文件，则意味着这是一个下载请求，因此他们需要将数据传递到下载管理器。

这也是在那里[安全浏览](https://safebrowsing.google.com/)检查情况。如果域和响应数据似乎与已知的恶意站点匹配，则网络线程将发出警报以显示警告页面。Additionally, [**C**ross **O**rigin **R**ead **B**locking (**CORB**)](https://www.chromium.org/Home/chromium-security/corb-for-developers) check happens in order to make sure sensitive cross-site data does not make it to the renderer process.

### 步骤3 查找渲染器进程

一旦完成所有检查，并且Network线程确信浏览器应导航到请求的站点，则Network线程将告知UI线程数据已准备就绪。然后，UI线程找到一个渲染器进程来进行网页渲染。

网络请求存在延迟, 在步骤2执行的同时, UI线程尝试寻找渲染器进程. 这样当网络线程接收到数据的时候, 渲染器进程已经处于待机位置.

### 步骤4 提交导航

将准备号的数据和渲染器进程, 利用 IPC 将导航数据从浏览器进程传送到渲染器进程中. 这个过程是持续的, 渲染器进程可以持续接收 HTML 数据. 一旦浏览器进程监听到渲染器进程接收到数据的信号, 导航则视为完成, 文档加载阶段开始.

- 地址栏更新
- 安全指示符和站点设置UI反映了新页面的站点信息
- 标签的会话历史记录将被更新
- 因此后退/前进按钮将逐步浏览刚刚导航到的站点
- 会话历史记录存储在磁盘上

### 额外步骤 初始加载完成

提交导航后, 渲染器进程将持续加载资源并且渲染页面. 当渲染器进程 "完成" 渲染后, 他将 IPC 送回浏览器进程(在 onload 时间彻底执行完成后), UI 线程会停止标签页面上加载指示器的显示(就是那个小圆圈).

# 渲染器进程

渲染器进程负责渲染卡内部所有的事情. 渲染器进程中, 主线程处理绝大数用户接收到的代码. 如果使用 network worker 或者 service worker, 则有时部分工作交由 worker(线程) 处理. 合成器和光栅线程也在渲染进程内部.

渲染器进程的核心工作是将HTML，CSS和JavaScript转换为用户可以与之交互的网页。

## 解析

当渲染进程接收到了用于导航的提交消息且开始接收 HTML 数据. 主线程开始解析这些文本将其转为 DOM.

### 子资源加载

网站中引用的外部资源:

- image
- css
- javascript
- ...

这些文件会从缓存或者网络中加载. 主线程可以在解析 HTML 的时候一个一个的加载, 但是为了加快速度, "preload scanner"会同时执行. 如果有类似 `<img>` 或者 `<link>` 在 DOM 中, "preload scanner" 会拿上解析后的标记然后向浏览器进程的网络线程发起请求.

### JavaScript 会阻塞解析

如果 HTML 解析器发现 `<script>` 标签, 会停止解析等待脚本加载完成后继续解析. 因为脚本可能更改 DOM 结构, 导致

### 告诉浏览器你想要的加载姿势

对于 script 可以使用:

- async
- defer
- module

属性来让浏览器异步加载.

对于 link 可以使用:

- preload
- prefetch

来让资源优先加载.

## 样式计算

主线程会解析样式通过 CSS, 为每一个 DOM 上的节点添加计算后的样式. 这些信息用于描述基于 CSS 选择器 DOM 节点应用了哪些样式. 可以通过浏览器开发者工具的 computed 选项卡查看.

## 布局 layout

只有样式和DOM还不足以渲染出页面.

布局是查找元素几何形状的过程。主线程遍历DOM和计算样式，并创建布局树，该树具有诸如 x y 坐标和边界框大小之类的信息。布局树的结构可能与DOM树类似，但它仅包含与页面上可见内容有关的信息。如果`display: none`应用，则该元素不属于布局树（但是，具有的元素`visibility: hidden`在布局树中）。类似地，如果应用了具有类似内容的伪类，`p::before{content:"Hi!"}`即使它不在DOM中，它也将包含在布局树中。

## 绘制 paint

知道了样式和布局 layout 任然不足以呈现页面, 你还需要知道要绘制的顺序. 默认情况下是通过 HTML 中的顺序来绘制的, 但是可以通过 z-index 来控制显示层级, 从而控制绘制的顺序.

在这个过程中, 主线程遍历布局树来创建绘制记录. 绘画记录是对绘画过程的记录，例如“首先是背景，然后是文本，然后是矩形”。

### 更新渲染管道的成本很高

非常重要的一点就是:

- style
- layout
- paint

的每一个环节都依赖上一个环节, 换句话说上一个环节的修改会导致后续所有环节进行重新计算, 代价是高昂的.

如果要设置动画元素，浏览器必须在每帧之间运行这些操作。我们大多数显示器每秒刷新屏幕60次（60 fps）；当您在每一帧 frame 中在屏幕上移动物体时，动画将对人眼显得平滑。但是, 如果动画错过了某帧在下一帧执行, 这样的话动画会显得混乱.

即使渲染操作与屏幕刷新保持一致，这些计算仍在主线程上运行，这意味着在您的应用程序运行JavaScript时可能会阻止该计算。

您可以将JavaScript操作分成小块，并使用计划在每一帧运行 `requestAnimationFrame()`。有关此主题的更多信息，请参见 [优化JavaScript执行](https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution) 。您也可以[在Web Workers中](https://www.youtube.com/watch?v=X57mh8tKkgE)运行[JavaScript，](https://www.youtube.com/watch?v=X57mh8tKkgE) 以避免阻塞主线程。

## 合成

走到这一步渲染进程已经知道了:

- 文档结构
- 元素样式
- 几何信息
- 绘制顺序

利用这些信息转为屏幕上的像素的过程被成为 "光栅化".

现代浏览器的工作是复杂的. 合成是一种技术，将页面的各个部分分成不同的图层，分别对它们进行光栅化，通过一个单独的线程（称为合成线程）合成为页面。如果发生滚动, 由于层已经光栅化, 所需要做的就是合成一个新的帧即可. 动画可以利用同样的方式移动图层然后和成一个新的帧来解决.

你可以通过浏览器的开发者工具 图层面板(Layers Panel) 来观察页面是如何被拆分为多个层的.

### 拆分图层(Dividing into layers)

为了找出哪些元素需要图层支持, 主线程会遍历布局树(layout tree) 在 devtool 的性能面板中这个环节被称为 更新图层树("Update Layer Tree).

如果页面的某个部分需要建立图层(例如: 常见于页面做的的抽屉布局) 可以为 `will-change` 添加属性来告诉浏览器需要新建图层.

为所有的元素建立单独的图层是一个不错的想法, 但是更多的图层意味更多的性能开销, 所以这不是一个好的注意, 需要在两者间达到一个平衡.

### 主线程的栅格化和合成

一旦创建了图层树(拆分图层)并确定了绘制顺序(paint)，主线程便将该信息提交给合成线程。然后，合成器线程将每个图层栅格化。一层可能像页面的整个长度一样大，因此合成器线程将它们划分为图块(tile)，并将每个图块发送给栅格线程。栅格线程栅格化每个图块并将其存储在GPU内存中。

合成器线程可以优先处理不同的栅格线程，以便可以首先对视口（或附近）中的事物进行栅格化。图层还具有用于不同分辨率的多个图块，以处理诸如放大动作之类的事情。

一旦图块被栅格化后, 合成线程会收集图块信息(被称为 draw quads)去创建合成帧

|                          |                                                              |
| ------------------------ | ------------------------------------------------------------ |
| Draw quads               | 包含信息，例如图块在内存中的位置以及考虑到页面合成时在页面中绘制图块的位置。 |
| 合成帧(Compositor frame) | 一个用于表示页面的帧的 Draw quads 的集合.                    |

然后通过IPC将合成器帧提交给浏览器进程。此时，可以从UI线程（用于更改浏览器UI）或从其他渲染器进程（用于扩展）添加另一个合成器框架。这些合成器帧被发送到GPU，以将其显示在屏幕上。如果发生滚动事件，则合成器线程将创建另一个合成器框架以发送到GPU。

合成阶段存在的好处是它的工作是否完成和主线程无关. 合成线程不需要等待样式计算以及 JavaScript 的执行. 这就是为什么 [仅合成动画](https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/) 被认为是最佳的平滑表现的原因。如果需要重新计算布局或绘画，则必须涉及主线程。

# 从浏览器的角度理解输入事件

当发生用户手势（如屏幕上的触摸）时，浏览器进程将首先接收手势。由于选项卡内部交由渲染进程处理, 所以浏览器进程会将手势在何处发生以及类型发送给渲染进程.

# 合成器接收输入事件

如果该页面上没有任何输入事件侦听器，则合成器线程可以创建一个完全独立于主线程的新复合帧。但是，如果将某些事件侦听器附加到页面上怎么办？合成器线程将如何找出是否需要处理事件？

# 了解非快速滚动区域(Non-fast region)

由于运行JavaScript是主线程的工作，因此在合成页面时，合成器线程会将页面上具有事件处理程序的区域标记为“非快速可滚动区域”。通过获取此信息，如果事件发生在该区域中，则合成器线程可以确保将输入事件发送到主线程。如果输入事件来自该区域之外，则合成器线程将在不等待主线程的情况下进行新帧的合成。

也就是说:

1. 浏览器进程的 UI 线程发送用户手势到渲染进程
2. 渲染进程的合成线程会判断用户手势是否进入到了非快速滚动区域(即绑定了事件的区域)
   1. 如果事件发生在此区域中则合成器线程会将输入事件发送到主线程
   2. 如果输入事件来自区域之外, 则合成器线程将在不等待主线程的情况下进行新帧的合成

## 当编写事件处理程序时要注意

Web开发中常见的事件处理模式是事件委托。由于事件冒泡，因此您可以在最顶层的元素上附加一个事件处理程序，并根据事件目标委派任务。您可能已经看过或编写了如下代码。

```javascript
document.body.addEventListener('touchstart', event => {
    if (event.target === area) {
        event.preventDefault();
    }
});
```

由于您只需要为所有元素编写一个事件处理程序，因此此事件委托模式的人体工程学很有吸引力。但是，如果您从浏览器的角度查看此代码，则现在整个页面都被标记为不可快速滚动的区域。这意味着，即使您的应用程序不关心页面某些部分的输入，合成器线程也必须与主线程进行通信，并在每次输入事件发生时等待它。因此，合成器的平滑滚动能力被击败。

为了减轻这种情况的发生，您可以`passive: true`在事件监听器中传递选项。这向浏览器暗示您仍要在主线程中侦听事件，但是合成器也可以继续合成新的框架。

```javascript
document.body.addEventListener('touchstart', event => {
    if (event.target === area) {
        event.preventDefault()
    }
 }, {passive: true});
```

# 检查事件是否是 cancelable

你有一个只想横向滚动的盒子在页面上.

在指示事件中使用 `passive: true` 意味着页面滚动可以是顺滑的, 使用 `preventDefault` 来限制滚动的方向此时可能纵向的滚动已经开始了. 你可以使用 `event.cancelable` 用于检查.

```javascript
document.body.addEventListener('pointermove', event => {
    if (event.cancelable) {
        event.preventDefault(); // block the native scroll
        /*
        *  do what you want the application to do here
        */
    }
}, {passive: true});
```

另外，您可以使用CSS规则`touch-action`来完全消除事件处理程序。

```css
#area {
  touch-action: pan-x;
}
```

# 寻找事件目标

当合成器线程向主线程发送输入事件时，第一件要运行的是就是命中测试去找到事件目标(event target)。命中测试使用在渲染过程中生成的绘制记录数据来找出事件发生时对应坐标下的内容.

# 最小化事件分配到主线程

在上一篇文章中，我们讨论了典型的显示如何每秒刷新屏幕60次，以及如何保持节奏以实现平滑动画。对于输入，典型的触摸屏设备每秒发送60-120次触摸事件，而典型的鼠标每秒发送事件100次。输入事件的保真度高于我们的屏幕刷新能力。

如果类似的连续事件`touchmove`每秒被发送到主线程120次，那么与屏幕刷新的速度相比，它可能会触发大量的命中测试和JavaScript执行。

为了尽量减少对主线程过度调用，Chrome的聚结连续事件（如 `wheel`，`mousewheel`，`mousemove`，`pointermove`， `touchmove`）和延迟调度直到先下一权`requestAnimationFrame`。

任何离散事件，如`keydown`，`keyup`，`mouseup`，`mousedown`，`touchstart`，和`touchend` 被立即执行。

**PS**: 是不是说明事件的响应频率是和屏幕刷新率同步的.

## 使用`getCoalescedEvents`得到帧内事件

对于大多数Web应用程序，合并事件应该足以提供良好的用户体验。但是，如果要构建诸如绘制应用程序之类的东西并基于`touchmove`坐标放置路径 ，则可能会丢失中间的坐标以绘制平滑线。在这种情况下，可以`getCoalescedEvents`在指针事件中使用该方法来获取有关那些合并事件的信息。

```javascript
window.addEventListener('pointermove', event => {
    const events = event.getCoalescedEvents();
    for (let event of events) {
        const x = event.pageX;
        const y = event.pageY;
        // draw a line using x and y coordinates.
    }
});
```

> https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#The_browsers_we_will_talk_about

# 个人总结

最顶级的浏览器进程负责多个进程的通信.

chrome 尽可能的为每一个标签页建立一个进程, 为了域隔离现在每一个 iframe 都会建立一个进程(如果可能的话)

标签页单独分为一个进程的好处是某标签页奔溃后不会影响全局, 另外一个好处是提供进程隔离更加安全.

chrome 的进程结构会根据硬件进行调整, 主要体现在将浏览器进程拆分为多个独立的进程 UI进程 存储进程 网络进程.

事件输入首先由浏览器进程的UI线程接收到, 但是 UI 线程只知道位置坐标等信息, 它会把这些信息发送到当前的标签页所在的渲染进程的合成器线程. 绑定事件的区域被合成器线程标记为 "非快速滚动区域" , 当合成器接收到事件在 "非快速滚动区域" 内部, 合成器会通知主线程, 如果在外部合成器会在不等待主线程的情况下继续合成新的帧.

**提示**: 所以在全局使用事件监听器是一个非常不好的做法, 当输入事件发生总是会迫使合成器线程与渲染进程的主线程进行通信, 降低浏览器平滑滚动的能力.

