# 视觉格式化模型

本篇文章的绝大部分内容来自于 MDN:

> https://developer.mozilla.org/en-US/docs/Web/CSS/Visual_formatting_model

对应的中文翻译比较旧了本篇文章翻译了英文文章的部分内容.

视觉格式化模型(Visual Formatting Model) 描述了用户代理如何利用文档树 (document tree) 进行处理然后显示到可视媒体上.

再视觉格式化模型中, 再文档树上的每一个元素都会根据和模型(box model) 去生成一个或者多个盒子. 这些盒子的布局(不是盒子内部的布局而是如何布局盒子)受下面条件约束:

- 盒子的尺寸
- 盒子类型
- 定位方案
  - 普通文档流(normal flow)
  - float
  - absolute
- 文档树中元素之间的关系
- 其他的某些外部因素
  - 视口尺寸与位置
  - 所包含的图片的尺寸
  - 以及其他因素

有关视觉格式化模型的大部分信息再 CSS2 中定义, 但是在很多 level 3 规范中都添加了有关信息. 当你阅读相关规范的时候会找到有关 CSS2 规范的引用. 因此再阅读其他布局规范的时候事先了解这个规范将会很有用.

# 视口(viewport)的规则

在连续媒体中，视口是浏览器窗口的可视区域。当视口大小更改时，用户代理可以更改页面的布局-例如: 更改窗口的大小以及移动设备的屏幕方向.

如果视口小于文档的大小，则用户代理需要提供一种能力去滚动到未被显示的那部分文档. 

我们最经常碰见的滚动是在块状区域(block dimension)内滚动-以水平，从上到下的语言中垂直滚动。但是，你也有可能希望在内联区域(inline dimension )中进行同样的操作.

# 盒子生成(Box generation)

盒子生成是视觉格式化模型的一部分, 它从使用文档树中的元素去创建盒子(boxes). 被创建的盒子的类型有很多种, 不同的类型会影响对应的视觉格式(visual formatting). 盒子生成的类型由 CSS `display` 属性决定.

`display` 的最初定义在 CSS2 中在  [CSS Display Module Level 3](https://www.w3.org/TR/css-display-3/) 中被做了扩展, 部分有关 `display` 的术语得到了更新和明确.

CSS 为了完成从文档转为画布上的图像, 需要创建一个中间结构 "盒子树" (box tree) 这种结构用于表示渲染完成的文档.

盒子树中的每个盒子代表其在画布上的空间 和/或 时间的对应元素（或伪元素），而盒子树中的文本同样表示其对应文本节点的内容。

然后对于每一个元素, CSS会生成该元素的 `display` 属性值指定的零个或多个盒子。

> 盒子通常由它的 display 属性所影响, 例如一个拥有 `display:block` 的元素生成的盒子被称为 "block box"(块盒).

# 主盒

当一个元素生成一个或者多个盒子的时候, 其中存在一个主盒(principal box) 包含其后代盒子以及盒子树中的生成内容, 这个盒子也是定位方案中涉及的盒子.

除了主盒子, 某些元素会生成一些额外的盒子, 例如 `display:list-item` 会生成不止一个盒子(其中包括一个主盒子和一个子标记盒子(child market box). 有些 `display` 值会导致元素或者元素的后代不会生成任何盒子. (`none` 和 `contents` 属性)

# 匿名盒子

一个盒子没有对应的HTML元素 ,将创建匿名盒子. 例如: 你创建一个元素声明为 `flex` 然后让它包含了一段文本它没有经过任何标签包裹. 为了修复盒子树一个匿名盒子会被创建去包裹这个文本. 这个匿名盒子的行为就和 flex item 一样. 但是它不能向常规盒子那样被锁定或者被赋予样式因为你无法获取匿名盒子对应的元素.

```css
.flex {
  display: flex;
}

.flex > * {
  background-color: rebeccapurple;
  color: white;
}
```

```html
<div class="flex">
I am wrapped in an anonymous box 
<p>I am in the paragraph</p>
I am wrapped in an anonymous box.
</div>
```

同样的事情也会发生在文本与块元素相交差的时候:

```css
.example > * {
  background-color: rebeccapurple;
  color: white;
}
```

```html
<div class="example">
I am wrapped in an anonymous box 
<p>I am in the paragraph</p>
I am wrapped in an anonymous box.
</div>
```

这会创建三个盒子, 两个匿名盒子一个普通盒子由 `<p>` 标签生成.

有关匿名盒子的一点就是, 匿名盒子会继承父级样式, 但是你无法通过选中它们后去修改样式. 在上面的例子中只有 `<p>` 包裹的文本被赋予了样式.

内联匿名盒子(Inline anonymous boxes) 会在一段文本被内联元素(Inline element) 所分割的时候产生. 例如一段句子中部分文本被 `<em>` 所包裹. 这会创建三个内联盒子(inline boxes)两个内联匿名盒子和在中间的内联匿名盒子. 和匿名盒子一样它们只能继承样式但是无法独立设置样式.

某些格式上下文(formatting context)也会创建匿名盒子. Grid 布局的创建行为和之前的 flex 布局的类似, 将文本字符串转为对应的 匿名 grid item. 多列布局(Multiple-column) 围绕着列创建匿名盒子. 它们同样也无法设置样式或者被锁定. 表格布局将添加匿名盒子以创建合适的表结构, 例如它会添加一个匿名表格行 - 如果不存在一个 `display:table-row` 的盒子的话.

# 行框(Line boxes)

行框是用于包装每一行文本的框. 你可以通过浮动一个元素来观察 "行框" 与它的 "包含块" (containing block) 之间的区别.

在下面的这个例子中我们左浮动了一个 `<div>` 它跟随了一些文字, 它们的父级拥有背景颜色:

```css
.float {
  float: left;
  width: 200px;
  height: 200px;
  background-color: rebeccapurple;
  margin: 20px;
}

.following {
  background-color: #ccc;
}
```

```html
<div class="float"></div>
      <p class="following">This text is following the float, the line boxes are shortened to make room for the float but the box of the element still takes position in normal flow.</p>
```

![image-20200405205507416](./assets\image-20200405205507416.png)

在本例中所谓的 "包含块" 实际上指的是浮动元素和 `<p>` 的父元素, 而跟随浮动后面的文字的行框沿着浮动元素进行了收缩.

# 定位方案和 in-flow 和 out-of-flow 元素

在 CSS 中盒子的铺设方式是由定位方案(Positioning schemes)来决定的:

- normal flow
- floats
- absolute positioning

## 普通流

在普通流中包含:

- 块盒(block boxes)的块级格式化(block-level-formatting)盒子
- 内联盒(inline boxes)的内联级格式化(inline-level formatting)盒子
- 使用了绝对定位或者粘性定位的 块级/内联级 盒子

## 浮动

在浮动模型中，首先根据普通流布置一个盒子，然后从普通流中取出并定位，通常位于左侧或右侧。内容可能会沿着浮动的一侧流动。

## 绝对定位

在绝对定位模型（也包括固定定位）中, 盒子会从普通流中完全移出, 并相对于包含块（在固定定位的情况下是视口）来指定位置。

如果一个元素符合下列条件被称为脱离文档流(out of flow), 反之称为在文档流中(in flow):

- 浮动
- 绝对定位 (sticky absolute fixed)
- 是根元素

# 格式化上下文与 display 属性

可以将盒子(boxes)描述具有外部显示类型(outer display type) `block` 或者 `inline`. 这种外部显示类型指代盒子与盒子间的行为.

盒子同时还具有内部显示类型(inner display type), 决定着它的子代(children)的行为. 对于 普通块 (normal block) 和内联布局 (inline layout) 或者普通流 (normal flow) 它的显示类型是 `flow` 这意味着它的子元素是 `block`  `inline` 二者之一.

但是内部显示属性也可以是 `grid` 或者 `flex`, 在这种情况下它们的直接后代会当作 grid/flex 项显示(grid item / flex item). 在这种情况下元素被称为创建了 `flex` / `grid` 上下文. 在大多数情况下它们的工作方式类似于块级格式化上下文(block formatting context). 但是, 它们的直接后代的行为是 flex/grid 项和普通流中的项目行为不同.

## 独立格式化上下文

元素要不是参与格式化上下文要不就是建立包含块要不就是建立一个独立格式化上下文. 例如: 一个 Gird 容器为其子代建立了 `Grid Formatting Context`.

独立格式化上下文包含:

- 浮动元素
- margin 不会跨格式化上下文穿透

因此创建一个新的块状格式化上下文可以确保浮动元素在盒子的内部. 开发者经常使用 `overflow` 来清除浮动, 而 `overflow` 就会创建一个新的格式化上下文. 在 `display` 中有一个全新的属性 `flow-root` 会创建一个新的格式化上下文而没有任何因为修改 `overflow` 所带来的副作用.

## 块盒(block boxes)

在规范中，在某些位置将块盒(block boxes)，块级盒(block-level boxes)和块容器(block container)都称为块盒. 这几个术语是有区别的, 而块盒(Block boxes) 应该只在没有歧义的情况下使用.

### 块容器(block containers)

块容器要么仅包含参与内联格式化上下文(inline formatting context)的内联级别(inline level)的盒子，要么仅包含参与块格式化上下文(block formatting context)内的块级(block level)盒子。

因此之前讨论自动创建匿名盒子的行为是用于确保所有项目都可以参与 块/内 联格式化上下文. 当元素只包含块级盒子或者内联级盒子的时候这个元素才是一个块容器.

### 块级盒子与内联级盒子

这些分别是块容器内包含的盒子，它们分别参与内联或块布局。

### 块盒子

块盒子是一个块级盒子也是一个块容器. 一个块级盒子同时不是一个块容器(他可能是 flex 或者 grid 容器).

# 总结

块/内联级盒子参与 块/内联 级格式化上下文的创建, 它们的上下文中只能存在对应的盒子.

所谓的 块/内联 级格式化上下文 实际上和所谓的 IE 布局模型类似, 不是所有的元素都需要完整的位置几何等信息, 页面上的内容并非不同的元素内容都是相对于某个元素定位的. 页面中只需要部分元素拥有格式化上下文既可.

普通布局流分为三种, 它们是属于格式化上下文的. 如何理解这句话, 一个 `<div>` 使用 `overflow` 创建块级格式化上下文对吧, 根据上下文来确定对应的文档流:

- 块级格式化上下文
- 内联格式化上下文
- 相对定位

而文档流规定了盒子如何排放.

对了 "块级格式化上下文" 非常常见, 如何建立一个内联格式化上下文呢? 根据规范 一个非替换元素使用 `display:inline` 生成一个内联盒子(inline box).

重点来了 内联盒子 的规范说明是 内联盒子既是 内联级盒子 又包含其内联格式上下文的内容的盒子. 也就是说 `display:inline` 的内部是 "内联格式化上下文" 而它本身也是内联级盒子, 所以可以参与内联格式化上下文. 这说的通因为:

```html
<span>hello <em> world </em></span>
```

是没有问题的.

Except for table boxes, which are described in a later chapter, and replaced elements, a block-level box is also a block container box. A block container box either contains only block-level boxes or establishes an inline formatting context and thus contains only inline-level boxes. Not all block container boxes are block-level boxes: non-replaced inline blocks and non-replaced table cells are block containers but not block-level boxes. Block-level boxes that are also block containers are called block boxes.

The three terms "block-level box," "block container box," and "block box" are sometimes abbreviated as "block" where unambiguous.