# 标题 - 移动端布局原理

# 前言

在我的[上篇文章](https://segmentfault.com/a/1190000020672995#articleHeader2)中讨论了有关移动端布局基础概念, 其中包括了移动端是如何渲染页面, 以及 `<meta name="viewport">` 的使用方式.

本篇文章中我们会利用之前所学习到的内容来讨论移动端布局中存在的问题, 以及解决的方法, 以及现在流行的解决方案之间的差异与实现.

# 回顾

一个未经过任何设置的页面, 在移动端该页面的宽度为 980px(典型值).

由于页面的宽度固定, 但是移动设备的屏幕尺寸却多种多样, 大尺寸的屏幕无法利用高分辨率的优势显示更多的内容, 低分辨率的设备需要放大才可以看清页面上的内容.

所以移动端页面中都会控制页面视口的大小和设备一致:

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```

上述的代码会令浏览器去使用使用一个 "适应设备的分辨率" 去渲染, 一般来说往往越大的屏幕这个值越大, 那么不同的设备根据屏幕大小的部分也就会有相应的页面宽度了.

那么这个 "适应设备的分辨率" 的值是多少呢, 我们先得了解 "设备像素"(物理像素) 以及 "设备独立像素"(css 像素)之前的差别.

因为市面上的高分辨率的设备越来越多, 移动端页面的渲染, 不可能像PC页面那样 1个 `css像素` 就对应屏幕上的一个物理像素, 如果真的这样移动设备上的内容将会小到看不清.

所以终端制造商会让多个设备像素去显示一个设备独立像素, 例如让 4个物理像素 去渲染一个css像素, 那么 "设备像素比" `设备像素(物理像素) / 设备独立像素(css像素)` 也就是 4/1 = 4 就诞生了, 简写为 DPR.

你可以通过下列代码来获取它的大小:

```javascript
console.log(window.devicePixelRatio)
```

实际上 "适应设备的分辨率" 就是经过缩放后的最终大小, 例如一个手机屏幕的横向分辨率为 `1000px` DPR 为 2, 那么实际的页面宽度就是 `1000(设备像素) / 2(设备像素比) = 500px` .

# 主要问题

通过设置 `<meta content="viewport">` 我们在不同的设备上都可以获取到最棒的页面大小.

但是问题随之而来, 设计师给的设计图往往只有一张, 但是我们却需要兼容不同尺寸的屏幕, 出于成本考虑显然我们不可能为每一种分辨率都进行定制. 更为棘手的是设计师往往使用 `iphone6` 的 750px 作为设计稿的标准, 很少有页面大小是这个值.

所以关键的问题是要 **保证设计图上的内容可以完美且保持比例的在不同尺寸的设备上显示** . 那简单, 只要在所有需要指定尺寸的地方指定比例大小不指定固定宽度不就可以了吗, 很可惜**保持比例**思路是对的, 但是想要直接实现还是需要一些额外的过程.

接下来我们将继续深挖讨论问题的核心所在.

# 解决问题

## 基本思路

**按照比例缩放来适应不同页面大小是解决问题的核心所在**.

## 方案1: 页面适应设计稿

因为移动端的设计稿的标准宽度都是 750px, 如果我们让所有的设备的 `viewport` 的宽度和设计稿一致, 那么设计稿上的 1px 就是 页面上的 1px.

思路很简单直接的实现也只需要一行代码:

```html
<meta name="viewport" content="width=750, user-scalable=no">
```

现在视口被设置成为了 750px, 设计稿中的 1px 就是实际页面中的 1px 了.

但是这个方案有个致命的缺陷, 设计稿必须统一为 750px, 由于视口宽度固定无法使用媒体查询, 在拥有大尺寸的移动设备中的字体会变大而不是容纳更多的内容, 如果你引入了第三方框架, 它们很可能无法正常工作. 另外在不同尺寸设备上实现固定文字大小也是非常困难的.

不过如果你的页面非常简单或者没有其他的条条框框束缚, 这绝对是最简单有效的手段之一.

## 方案2: rem 适应

rem 方案可谓是尽人皆知了, 流行的解决方案是淘宝的 `lib-flexable` 虽然经常被人吐槽有各种小问题, 不过在合适的场景下该用还是得用, 基本工作原理如下.

首先我们知道 rem 单位的大小就是 `<html>` 元素的 `font-size`, 例如:

```css
html {
    font-size:20px;
}

p{
    font-size:1rem; /* 等同于 20px */
}

div{
    font-size:.5rem; /* 等同于 10px */
}
```

现在我们将设计稿按照宽度分为 10 等分, 例如 750px / 10  = 75px, 为什么这么做呢? 因为在 750px 下 75px 就是 10% 的宽度, 如果我们将 `html` 的 `font-size` 设置为 `75px` 那么 `1rem` 就是 10% 的页面宽度, 如果页面中的一个元素 35px 宽, 我们只要给他指定 `.5rem` 就可以了, 也就是说我们把 rem 当做了一个百分比单位.

使用 `rem` 单位的原因是在早期的移动端开发中它的兼容性良好, 所以被广泛使用, 但这并不意味这他是最优秀的解决方案.

通过阅读 `lib-flexable` 的源码, 它的工作原理如下:

1. 获取 DPR (设备像素比)
   1. 如果已经存在 `<meta name="viewport" content="xxx">` 利用上面的属性进行初始化 DPR.
   2. 如果是 `iphone` 为了便于计算需要平整 DPR, 因为 DPR 不总为整数, 所以为了方便计算 DPR 被进行了近似取整, DPR >= 2 的设置为 2, DPR >= 3 的设置为 3, 其余为 1. 例如某款 `iPhone` 的实际 DPR 为 2.5, 近似为 2 , 然后在将页面缩放设置为 1 / 2 = 0.5 也就是视口宽度增加了一倍, 这个操作是为了后面设置字体大小做铺垫.
   3. 如果是安卓机 DPR 默认为1.
2. 设置 `body` 元素的字体大小计算方式为 12 * DPR, 这样设置的目的在于无论页面是否因为 DPR 而缩放, 在 `body` 下方的元素在继承 `font-size` 大小的时候都是 DPR 为 1 情况下的大小. 还有一个非常重要的原因是在 `body` 上设置的值是用来覆盖后面设置在 html 上的字体大小的.
3. 设置 `html`上的 `font-size` 的大小, 基本的逻辑是获取当前页面的宽度 / 10, 实际代码为 `document.documentElement.getBoundingClientRect().width / 10` 这样在子元素中使用 `rem` 的时候 `1rem = 10%`, 但是这里还做了一些额外的处理.
   1. 如果浏览页面的设备是大屏设备例如 ipad 或者 Pc, 则 `1rem` 等于 `54px`. 因为移动端页面能够达到的最大为 540px(考虑 DPR 的情况), 超过这个值则是大屏设备的范围, 此时 54px 作为一个经验值不至于在大屏幕上适配后显得过于比例失调.
4. 监听页面的变化, 当页面改变执行步骤 3

如果不考虑可靠性, 这里可以给出一个最简示例:

```javascript
// 获取 DPR = 物理像素 / 设备像素
const devicePixelRatio = window.devicePixelRatio;
// 获取页面缩放大小, 值越小意味着 css像素 增多, 页面整体缩小, 反之意味着 css像素 减少, 页面整体放大.
const scale = 1 / devicePixelRatio;
// 设置页面缩放到物理像素大小
document.write(`<meta name="viewport" content="initial-scale=${scale}, maximum-scale=${scale}, minimum-scale=${scale}">`)
// 设置 body 的 font-size 为观感 12px. DPR 大 -> css像素增多 -> 页面观感缩小 -> 所以要放大字体抵消字体缩小
document.body.style.fontSize = 12 * devicePixelRatio + 'px';
// 设置 html 的大小, 让后代元素使用 1rem 等于 10% 的页面宽度
document.documentElement.style.fontSize = document.documentElement.getBoundingClientRect().width / 10 + 'px';
```

### 拓展1: 使用媒体查询

在最初的版本中我们使用了 `javascript` 来控制 `html` 元素的 `font-size`. 基本的原则就是根据页面的大小, 来进行控制字体的大小.

如果仅仅是为了完成上述功能, 在不使用 `javascript` 的情况下, 仅使用 `css` 就可以完成.

通过使用媒体查询, 我们拥有在不同尺寸屏幕下改变样式的能力:

```css
html {
    font-size: 16px;
}
@media screen and (min-width: 600px) {
    html {
        font-size: 18px;
    }
}
```

上面的代码在设备独立像素(css 像素)大于 600px 的情况下页面会更改 `font-size` 的大小.

假如设计师给的设计稿为 1000px, 为了兼容不同尺寸的设备, 我们准备使用 `rem` 作为相对单位使用.

和 `lib-flexable` 一样, 我们将页面横向等分 10 份, 对于设计稿来说那么每一分也就是 1000/10 = 100px.

对于屏幕宽度大于 320px 的手机来说 1 份就相当于 320 / 10 = 32px:

```css
html {
    font-size: 32px;
}
```

对于屏幕大于 375px 的手机来说 1份就相当于 375 / 10 = 37.5px:

```css
html {
    font-size: 32px;
}

@media screen and (min-width: 375px) {
    html {
        font-size: 37.5px;
    }
}
```

依次类推我们可以在不同尺寸间灵活的定义, 而且不一定切割为10份, 可以根据具体需求灵活改变.

但是这种方案当然有缺点, 其中最为致命的一点就是过渡不够平滑, 浏览器会在经过断点的时候闪烁, 当然可以通过定义大量的媒体查询解决, 但是这个工作量想想就可怕, 而且没有维护性可言.

### 拓展2: 使用 `calc` 与 `vw`

这部分是主要参考了张鑫旭老师的[这片文章](https://www.zhangxinxu.com/wordpress/2016/08/vw-viewport-responsive-layout-typography/), 在这里我来做一下简单的总结.

和标题一样在这个方案总使用了 `calc` 和 `vw `属性, 所以老式浏览器的兼容就不要考虑了.

但是这个方案可以确保浏览器在缩放的过程中平滑的改变 `html` 元素的字体大小.

该方案的工作方式为**屏幕在某个尺寸区间变化时 `html` 元素可以在固定的两个字体区间平滑的改变大小**. 

> 例如: 
>
> 浏览器宽度在600px~1000px变化的时候，html根元素的`font-size`大小是18px~22px之间对应变化.

则可以使用下方的代码:

```css
html { font-size: calc(18px + 4 * (100vw - 600px) / 400); }
```

这个公式的计算值为:

```00
// 600px 的计算结果
calc(18px + 4 * (600px - 600px) / 400) = 18px
// 400px 的计算结果
calc(18px + 4 * (400px - 600px) / 400) = 16px
// 1000px 的计算结果
calc(18px + 4 * (1000px - 600px) / 400) = 22px
// 1600px 的计算结果
calc(18px + 4 * (1600px - 600px) / 400) = 28px
```

最后我们还可以结合媒体查询令浏览器在不同区间拥有最佳的缩放效果, 这里给出张老师提供的最佳实践的代码, 其中使用百分比单位的定义是为了兼容 `Safari` 浏览器:

```css
html {
    font-size: 16px;
}

@media screen and (min-width: 375px) {
    html {
        /* iPhone6的375px尺寸作为16px基准，414px正好18px大小, 600 20px */
        font-size: calc(100% + 2 * (100vw - 375px) / 39);
        font-size: calc(16px + 2 * (100vw - 375px) / 39);
    }
}
@media screen and (min-width: 414px) {
    html {
        /* 414px-1000px每100像素宽字体增加1px(18px-22px) */
        font-size: calc(112.5% + 4 * (100vw - 414px) / 586);
        font-size: calc(18px + 4 * (100vw - 414px) / 586);
    }
}
@media screen and (min-width: 600px) {
    html {
        /* 600px-1000px每100像素宽字体增加1px(20px-24px) */
        font-size: calc(125% + 4 * (100vw - 600px) / 400);
        font-size: calc(20px + 4 * (100vw - 600px) / 400);
    }
}
@media screen and (min-width: 1000px) {
    html {
        /* 1000px往后是每100像素0.5px增加 */
        font-size: calc(137.5% + 6 * (100vw - 1000px) / 1000);
        font-size: calc(22px + 6 * (100vw - 1000px) / 1000);
    }
}
```

### 拓展3: 使用构建工具

现在的 web 开发构建工具已经是不可缺少的一环了, 构建工具可以在打包前对代码进行处理, 让许多前端开发环节工程化成为了可能.

所以便诞生了诸多为移动端布局设计的工具, 对于 `rem` 方案来说, 基本的逻辑就是在开发时候页面使用和设计稿一致的 px 单位, 在最终的打包过程中, 使用构建工具将 px 单位自动转为目标单位.

所以采用哪种方案取决于你使用的开发框架以及构建工具, 大漠老师有篇文章完整的讨论了 Vue 项目中如何处理这种需求:

> https://www.jianshu.com/p/1f1b23f8348f



## 方案3: vm自适应

在 `rem` 节中我提到, `rem` 的流行主要是因为兼容性问题, 但这些都是过去式了.

`rem` 的主要目的是让 `rem` 变成一个百分比单位, 现在我们已经有了这样的单位了 `vw` 和 `vh` 分别代表了视口的大小本身, `1vw` 值得就是 `1%` 的页面宽度.

和 `rem` 方案不同是在 `rem` 方案中我们使用的是 `rem` 作为单位, 但是在 `vm` 中我们却使用 `px` 作为单位.

对于一个 750px 的设计稿来说, 等分 100 份每份也就是 7.5 px 的宽度也就是 `1vm`. 我们期待的是**在编写代码阶段按照 px 进行编写但是在生产环境中将 px 转为 vm**.

为了实现这个需求我们需要使用工具来辅助我们的开发工作.

> https://www.jianshu.com/p/1f1b23f8348f
>
> https://blog.csdn.net/qq_21729177/article/details/79466951

## 方案4: 固定尺寸单位与 flex 布局

## 方案5: 流式布局与响应式

## 方案4: 利用构建工具

## 总结

# 其他问题

## 图片

## 边框

# 参考

> https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html
>
> [lib-flexable 源码阅读](https://segmentfault.com/a/1190000007701921)
>
> https://segmentfault.com/q/1010000004453194
>
> https://segmentfault.com/q/1010000012707256
>
> https://www.jianshu.com/p/1f1b23f8348f
>
> https://juejin.im/post/5e6caf55e51d4526ff026a71#heading-8
>
> https://www.cnblogs.com/agansj/p/10145599.html